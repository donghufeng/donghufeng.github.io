<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>东湖风的札记</title>
  
  <subtitle>Keep Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/donghufeng/"/>
  <updated>2020-04-26T05:52:52.756Z</updated>
  <id>https://github.com/donghufeng/</id>
  
  <author>
    <name>xu xusheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>角动量</title>
    <link href="https://github.com/donghufeng/2020/04/26/%E8%A7%92%E5%8A%A8%E9%87%8F/"/>
    <id>https://github.com/donghufeng/2020/04/26/%E8%A7%92%E5%8A%A8%E9%87%8F/</id>
    <published>2020-04-26T01:49:43.000Z</published>
    <updated>2020-04-26T05:52:52.756Z</updated>
    
    <content type="html"><![CDATA[<p>简单总结角动量理论中的一些结论。<br><a id="more"></a></p><h2 id="角动量"><a href="#角动量" class="headerlink" title="角动量"></a>角动量</h2><p>满足如下对易关系的量都可称为角动量：</p><script type="math/tex; mode=display">[J_i,J_j]=i\hbar \varepsilon_{ijk}J_k</script><p>写为矢量形式：</p><script type="math/tex; mode=display">\begin{aligned}\left(J\times J\right)_k&=\varepsilon_{kij}(J_iJ_j-J_jJ_i)\\&=i\hbar\varepsilon_{ijk}\varepsilon_{kij}J_k\\&=i\hbar J_k\\J\times J&=i\hbar J\end{aligned}</script><p>这里$J_{i,j,k}$称为角动量的分量，定义总角动量算符为：</p><script type="math/tex; mode=display">J^2=J_xJ_x+J_yJ_y+J_zJ_z</script><p>则有：</p><script type="math/tex; mode=display">[J_i,J^2]=0</script><p>定义：</p><script type="math/tex; mode=display">J_\pm=J_x\pm iJ_y</script><p>有对易关系，</p><script type="math/tex; mode=display">\begin{aligned}[J_+,J_-]&=2\hbar J_z\\[J_z,J_\pm]&=\pm\hbar J_\pm\end{aligned}</script><h2 id="旋转算符"><a href="#旋转算符" class="headerlink" title="旋转算符"></a>旋转算符</h2><p>角动量与绕任意轴旋转算符之间的关系：</p><script type="math/tex; mode=display">R_n(\phi)=\exp \left(-iJ\cdot e_n\phi/\hbar\right)</script><h2 id="本征值"><a href="#本征值" class="headerlink" title="本征值"></a>本征值</h2><p>总角动量和$J_z$的本征方程为：</p><script type="math/tex; mode=display">\begin{aligned}J^2 \left|j,m\right>&=j(j+1)\hbar^2 \left|j,m\right>\\J_z \left|j,m\right>&=m \hbar \left|j,m\right>\end{aligned}</script><p>其中，$m=-j,-j+1,\cdots,j-1,j$，共可取$2j+1$个值。<br>另外有</p><script type="math/tex; mode=display">\begin{aligned}J_+ \left|j,m\right>&=\hbar \sqrt{(j-m)(j+m+1)}\left|j,m+1\right>\\J_- \left|j,m\right>&=\hbar \sqrt{(j+m)(j-m+1)}\left|j,m-1\right>\\\end{aligned}</script><h2 id="自旋"><a href="#自旋" class="headerlink" title="自旋"></a>自旋</h2><p>以自旋1/2为例，本征态为：</p><script type="math/tex; mode=display">\left|+\right>=\left|1/2,1/2\right>,\left|-\right>=\left|1/2,-1/2\right></script><p>因此，各自旋算符的矩阵表示为：</p><script type="math/tex; mode=display">S_z=\frac{\hbar}{2} \begin{pmatrix}1&0\\0&-1\end{pmatrix},S_+=\hbar \begin{pmatrix}0&0\\1&0\end{pmatrix},S_-=\hbar \begin{pmatrix}0&1\\0&0\end{pmatrix}</script><p>因此有：</p><script type="math/tex; mode=display">\begin{aligned}S_i=\frac{\hbar}{2}\sigma_i=\hbar I_i\end{aligned}</script><p>自旋绕任意轴旋转的算符为：</p><script type="math/tex; mode=display">R_n(\phi)=\exp \left(-iS\cdot e_n\phi/\hbar\right)=\exp \left(-i\sigma\cdot e_n\phi/2\right)</script><h2 id="自旋磁矩"><a href="#自旋磁矩" class="headerlink" title="自旋磁矩"></a>自旋磁矩</h2><p>经典理论里面，磁矩可写为：</p><script type="math/tex; mode=display">\mu=Ia</script><p>其中$I$为电流，$a$为电流所在的面积矢量。</p><p>在磁场中，磁矩所受到的力矩和势能分别为：</p><script type="math/tex; mode=display">\begin{aligned}\tau&=\mu\times B\\U&=-\mu\cdot B\end{aligned}</script><p>在量子理论中，自旋磁矩可写为：</p><script type="math/tex; mode=display">\mu=g\frac{q}{2m}S=\gamma S</script><p>以电子为例，</p><script type="math/tex; mode=display">\mu_e=-g_e\frac{e}{2m_e}S</script><p>当外加磁场时，电子将做拉莫尔进动，设自旋角动量为$S$，则有：</p><script type="math/tex; mode=display">\tau=\frac{dS}{dt}=\mu_e\times B</script><p>选择磁场方向为$z$方向，则有：</p><script type="math/tex; mode=display">\omega=\frac{dS}{dt}/S=g_e\frac{e}{2m_e}B=g_e\frac{\mu_b}{\hbar}B=\gamma_eB</script><p>这里，$\mu_b=\frac{e\hbar}{2m_e}$是波尔磁子，$\gamma_e$为电子的旋磁比。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单总结角动量理论中的一些结论。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="角动量" scheme="https://github.com/donghufeng/tags/%E8%A7%92%E5%8A%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Note on Quantum Information-光量子方案</title>
    <link href="https://github.com/donghufeng/2020/04/23/Note-on-Quantum-Information-%E5%85%89%E9%87%8F%E5%AD%90%E6%96%B9%E6%A1%88/"/>
    <id>https://github.com/donghufeng/2020/04/23/Note-on-Quantum-Information-%E5%85%89%E9%87%8F%E5%AD%90%E6%96%B9%E6%A1%88/</id>
    <published>2020-04-23T08:42:16.000Z</published>
    <updated>2020-04-23T10:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>光量子方案。<br><a id="more"></a></p><h2 id="相干态"><a href="#相干态" class="headerlink" title="相干态"></a>相干态</h2><p>激光产生的态是相干态，写为</p><script type="math/tex; mode=display">\left|\alpha\right>=e^{-|\alpha|^2/2}\sum_{n=0}^\infin\frac{\alpha^n}{\sqrt{n!}}\left|n\right></script><p>相干态是降算符的本征态。相干态的平均光子数为$\left&lt;\alpha\right|n\left|\alpha\right&gt;=\left|\alpha\right|^2$，因此通过调节衰减器，可以控制相干态的$\alpha$，例如当$\alpha=\sqrt{0.1}$时，</p><script type="math/tex; mode=display">\left|\alpha\right>=\sqrt{0.90}\left|0\right>+\sqrt{0.09}\left|1\right>+\sqrt{0.002}\left|2\right>+\cdots</script><p>此时，该激光器有10%的概率发射出光子，而其中有95%的是单光子。</p><h2 id="参量下转换"><a href="#参量下转换" class="headerlink" title="参量下转换"></a>参量下转换</h2><p>当光透过某些晶体时，会产生参量下转换过程，对于$\omega_0$的入射光，透过晶体后会产生两束频率分别为$\omega_1$和$\omega_2$的出射光，且满足$\omega_0=\omega_1+\omega_2$。</p><h2 id="光量子控制手段"><a href="#光量子控制手段" class="headerlink" title="光量子控制手段"></a>光量子控制手段</h2><h3 id="相移"><a href="#相移" class="headerlink" title="相移"></a>相移</h3><p>经过长度为$L$，折射率为$n_0$的晶体后，光会有$e^{i(n-n_0)L\omega/c_0}$的相位移动</p><h3 id="分束"><a href="#分束" class="headerlink" title="分束"></a>分束</h3><p>半透半反镜会对光产生分束效果，从量子的角度来说，两束垂直入射的光，经过半透半反镜后两束光可写为：</p><script type="math/tex; mode=display">\begin{aligned}a_ \text{out}&=a_ \text{in}\cos{\theta}+b_ \text{in}\sin{\theta}\\b_ \text{out}&=-a_ \text{in}\sin{\theta}+b_ \text{in}\cos{\theta}\end{aligned}</script><p>当$\theta=45$°时，分束的效果可以用如下图表示<br><img src="/img/fenshu.jpg" alt="分束">g</p><h3 id="克尔效应"><a href="#克尔效应" class="headerlink" title="克尔效应"></a>克尔效应</h3><p>某些晶体具有克尔效应：晶体折射率跟其内部的光强有关系：</p><script type="math/tex; mode=display">n(I)=n+n_2I</script><p>因此，当两束强度相同的光入射到克尔效应的晶体中时，每束光都会有$e^{in_2IL\omega/c_0}$的额外相移。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;光量子方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子方案" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Note on Quantum Information-谐振子方案</title>
    <link href="https://github.com/donghufeng/2020/04/23/Note-on-Quantum-Information-%E8%B0%90%E6%8C%AF%E5%AD%90%E6%96%B9%E6%A1%88/"/>
    <id>https://github.com/donghufeng/2020/04/23/Note-on-Quantum-Information-%E8%B0%90%E6%8C%AF%E5%AD%90%E6%96%B9%E6%A1%88/</id>
    <published>2020-04-23T07:50:17.000Z</published>
    <updated>2020-04-23T08:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>谐振子方案。<br><a id="more"></a></p><h2 id="谐振子哈密顿量"><a href="#谐振子哈密顿量" class="headerlink" title="谐振子哈密顿量"></a>谐振子哈密顿量</h2><p>谐振子的哈密顿量为：</p><script type="math/tex; mode=display">H=\hbar \omega \left(a^\dagger a+\frac{1}{2}\right)</script><p>其中升降算符$a\dagger$、$a$满足：</p><script type="math/tex; mode=display">\begin{aligned}a^\dagger \left|n\right>&=\sqrt{n+1}\left|n+1\right>\\a \left|n\right>&=\sqrt{n}\left|n-1\right>\\a^\dagger a \left|n\right>&=n \left|n\right>\end{aligned}</script><h2 id="态演化"><a href="#态演化" class="headerlink" title="态演化"></a>态演化</h2><p>忽略掉零点能带来的全局相位后，任意的处态$\left|\psi(0)\right&gt;=\sum_{n}c_n \left|n\right&gt;$，在谐振子哈密顿量下的演化为：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi(t)\right>&=e^{-iHt/\hbar}\left|\psi(0)\right>\\&=e^{-ia^\dagger a\omega t}\left|\psi(0)\right>\\&=\sum_nc_ne^{-in\omega t}\left|n\right>\end{aligned}</script><h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><p>以CNOT门为例，在谐振子上作用量子门操作。<br>将逻辑比特于Fock态之间做如下的映射：</p><script type="math/tex; mode=display">\begin{aligned}\left|00\right>_L&=\left|0\right>\\\left|01\right>_L&=\left|2\right>\\\left|10\right>_L&=(\left|4\right>+\left|1\right>)/\sqrt{2}\\\left|11\right>_L&=(\left|4\right>-\left|1\right>)/\sqrt{2}\end{aligned}</script><p>此时，CNOT门则为将系统在谐振子哈密顿量下演化$t=\pi/\omega$，有上可知，进过时间$t$演化后，Fock态会产生一个相位为$e^{-in\pi}=(-1)^n$，因此，当$n$为奇数时，经过演化后会产生$\pi$的相位，对照逻辑比特的映射关系可知满足CNOT门。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;谐振子方案。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子方案" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E6%96%B9%E6%A1%88/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu20.04中一些快捷键</title>
    <link href="https://github.com/donghufeng/2020/04/21/Ubuntu20-04%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://github.com/donghufeng/2020/04/21/Ubuntu20-04%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-04-21T11:56:29.000Z</published>
    <updated>2020-04-26T01:51:08.340Z</updated>
    
    <content type="html"><![CDATA[<p>快捷键<br><a id="more"></a></p><p>ctrl+alt+b：打开浏览器<br>ctrl+alt+t：打开终端<br>ctrl+alt+v：打开vscode<br>alt+q：关闭程序<br>super：显示打开的所有应用<br>super+a：显示电脑中的所有应用<br>alt+w：移动窗口</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快捷键&lt;br&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的一些文件</title>
    <link href="https://github.com/donghufeng/2020/04/21/Linux%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/"/>
    <id>https://github.com/donghufeng/2020/04/21/Linux%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-21T11:17:27.000Z</published>
    <updated>2020-04-21T11:37:28.649Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍Linux中的一些系统文件。</p><a id="more"></a><h2 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a><code>/etc/profile</code></h2><p>用户登录时，系统自动运行的文件，可在此文件中加上自动运行的脚本，例如添加环境变量的脚本。</p><h2 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a><code>~/.bashrc</code></h2><p>用户打开<code>terminal</code>时自动加载的文件。只对当前用户有效。</p><h2 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a><code>/etc/fstab</code></h2><p>开机自动挂载硬盘的文件。</p><h2 id="etc-default-grub"><a href="#etc-default-grub" class="headerlink" title="/etc/default/grub"></a><code>/etc/default/grub</code></h2><p>开机系统选择界面设置文件，修改后通过<code>sudo update-grub</code>进行更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍Linux中的一些系统文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Note on Quantum Information - 噪声</title>
    <link href="https://github.com/donghufeng/2020/04/19/Note-on-Quantum-Information-%E5%99%AA%E5%A3%B0/"/>
    <id>https://github.com/donghufeng/2020/04/19/Note-on-Quantum-Information-%E5%99%AA%E5%A3%B0/</id>
    <published>2020-04-19T14:32:44.000Z</published>
    <updated>2020-04-19T14:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍噪声的基本概念和马尔可夫过程。</p><a id="more"></a><h2 id="经典噪声"><a href="#经典噪声" class="headerlink" title="经典噪声"></a>经典噪声</h2><p>假设某比特初始状态为$a, a\in(0,1)$，进过某个噪声影响后会变成$b, b\in(0,1)$，且有</p><script type="math/tex; mode=display">\begin{aligned}p(b=\bar{a})&=p\\p(b=a)&=1-p\end{aligned}</script><p>则受该噪声影响而产生的态转移为：</p><script type="math/tex; mode=display">\begin{pmatrix}q_0\\q_1\end{pmatrix}=\begin{pmatrix}1-p&p\\p&1-p\end{pmatrix}\begin{pmatrix}p_0\\p_1\end{pmatrix}</script><p>为了使演化前后的概率分布有意义，则状态转移的矩阵需要满足两个性质，1、<code>完备性</code>：矩阵的每列的和都为1；2、<code>正定</code>：矩阵的元素都是0到1之间的数。</p><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><p>假设有两个连续地系统噪声演化，$E_1$和$E_2$，如果此两个噪声没有任何关系，只跟当前系统的状态有关，那么称该过程为马尔可夫过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍噪声的基本概念和马尔可夫过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子噪声" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%99%AA%E5%A3%B0/"/>
    
      <category term="马尔可夫" scheme="https://github.com/donghufeng/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 历史补全</title>
    <link href="https://github.com/donghufeng/2020/04/19/ubuntu-%E5%8E%86%E5%8F%B2%E8%A1%A5%E5%85%A8/"/>
    <id>https://github.com/donghufeng/2020/04/19/ubuntu-%E5%8E%86%E5%8F%B2%E8%A1%A5%E5%85%A8/</id>
    <published>2020-04-19T03:40:56.000Z</published>
    <updated>2020-04-19T14:30:07.547Z</updated>
    
    <content type="html"><![CDATA[<p>如何在linux终端中通过调用page up和page down来补全命令。</p><a id="more"></a><p>打开<code>/etc/inputrc</code>，注释掉<code>history-search-backward</code>和<code>history-search-forward</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在linux终端中通过调用page up和page down来补全命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CCSD基础</title>
    <link href="https://github.com/donghufeng/2020/04/14/CCSD%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/donghufeng/2020/04/14/CCSD%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-13T16:05:45.000Z</published>
    <updated>2020-04-13T17:09:39.039Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍计算分子基态能量的<code>CCSD</code>理论。<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如图：<br><img src="/img/ccsd.png" alt="ccsd"></p><p>某个分子可用$n_q=10$个量子比特来描述，其电子数为$n_e=4$。上图为其轨道占据状态。其中有$\text{spin orbital}=10$，且$\text{spatial orbital}=5$，4个电子占据了最低层的空间轨道，未占据的轨道称为虚轨道。</p><h2 id="ccsd越迁"><a href="#ccsd越迁" class="headerlink" title="ccsd越迁"></a>ccsd越迁</h2><p>ccsd只考虑单电子和双电子越迁，不同的越迁可用对应的升降算符表示。对应与上图来说，单电子越迁可写为：</p><script type="math/tex; mode=display">T_1=a_i^\dagger a_j</script><p>当区分不同的电子自旋时，单电子越迁一共有：</p><script type="math/tex; mode=display">\left|T_1\right|=2C^1_\text{occ}C^1_\text{virt}</script><p>双电子越迁的升降算符表达式为：</p><script type="math/tex; mode=display">T_2=a_p^\dagger a_q a_r^\dagger a_s</script><p>可分为两种情况讨论，首先是两个电子的自旋相同，此时的可能性为</p><script type="math/tex; mode=display">2C_\text{virt}^2A_\text{occ}^2</script><p>其次为两个电子的自旋不同，此时可能性为：</p><script type="math/tex; mode=display">(C_\text{occ}^1C_\text{virt}^1)^2</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍计算分子基态能量的&lt;code&gt;CCSD&lt;/code&gt;理论。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子化学" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E5%8C%96%E5%AD%A6/"/>
    
    
      <category term="量子化学" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>量子线路求导续</title>
    <link href="https://github.com/donghufeng/2020/04/02/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC%E7%BB%AD/"/>
    <id>https://github.com/donghufeng/2020/04/02/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC%E7%BB%AD/</id>
    <published>2020-04-02T04:32:05.000Z</published>
    <updated>2020-04-02T04:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>推导对含参数的量子线路的求导。<br><a id="more"></a></p><h2 id="利用缓冲求梯度步骤"><a href="#利用缓冲求梯度步骤" class="headerlink" title="利用缓冲求梯度步骤"></a>利用缓冲求梯度步骤</h2><p>假设有哈密顿量$H$和含参数的线路$C$，则待优化的可观察量为：</p><script type="math/tex; mode=display">E(\theta)=\left<\psi_0\right|C^\dagger HC\left|\psi_0\right></script><p>还是以上面的量子线路为例：</p><script type="math/tex; mode=display">C(\theta_1,\theta_2,\theta_3)=XXU_1(\theta_1)U_2(\theta_1,\theta_2)U_3(\theta_2)U_4(\theta_1)XXXU_5(\theta_3)U_6(\theta_3)XU_7(\theta_1)U_8(\theta_1)XX</script><p>并采用分割：</p><script type="math/tex; mode=display">\begin{aligned}Q_1&=\{\{2,3,5\},\{12,13\}\}\\Q_2&=\{\{3,4\}\}\\Q_3&=\{\{9,10\}\}\end{aligned}</script><p>当求期望值对$\theta_1$的导数时，对于$Q_1$的第一个子集，我们需要缓冲下来的态为：</p><script type="math/tex; mode=display">C_{[0,1]}\left|\psi_0\right>,\left<\psi_0\right|C^\dagger H C_{[6,15]}</script><p>其中$C_{[a,b]}$表示线路的第$a$个门到第$b$个门，当其作用在右矢上时，是从左向右选择线路上的门依次作用，当其作用在左矢上时，是从右向左选择线路上的门依次作用。</p><p>对于一般情况，如何在期望值的首次演化过程中缓存下对应他态，供求梯度使用呢？</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h3><p>在作用哈密顿量之前，也即在演化$C \left|\psi_0\right&gt;$阶段时，判断当前准备作用的门是否为某个参数的某个分割的开始，如果有，则先缓存下现阶段的量子态，如当作用$U_1(\theta_1)$时，其为量子线路中的第2个门，而第二个门刚好是$\theta_1$参数的第一个分割的开始，因此，需要缓存下还未作用第2个门时的量子态。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h3><p>在作用哈密顿量之后，也即在演化$C^\dagger H C \left|\psi_0\right&gt;$时，判断当前准备作用的门是否为某个参数的某个分割的结束，如果有，则先作用该门，然后再缓存下量子态。</p><p>为了求梯度时读取缓存态方便，我们构造一个存储缓存态的结构：</p><script type="math/tex; mode=display">V=[V_1,V_2,V_3],V_1=[[\times,\times],[\times,\times]]</script><p>这里$\left|V_i[j]\right|=\left|Q_i\right|,\left|V_i\right|=2$，$V_i[0][j]$表示分割$Q_{i,j}$在<strong>第一阶段</strong>时缓存的态，$V_i[1][j]$表示分割$Q_{i,\left|Q_i\right|-1-j}$在<strong>第二阶段</strong>时缓存的态。</p><p>为了方便，我们还需要生成一个用于查找当前门是否为某个参数的某个分割的开始或者某个参数的某个分割结束的列表$L$，其结构可写为：</p><script type="math/tex; mode=display">L=[L_0,\cdots,L_{15}],L_0=[[],[]],\cdots,L_2=[[\theta_1],[]],\cdots,L_4=[[],[\theta_4]]</script><p>这里$\left|L\right|=\left| C\right|$，$L_i$有两个元素，第一个元素表示当前门是哪些参数的某个分割的开始，第二个元素表示当前门是哪些参数的某个分割的结束。如当第一阶段作用$C_2=U_1(\theta_1)$时，我们发现$L_2$的第一个元素不为空，为$\theta_1$，因此，我们将$V_1[0]$append当前缓存下来的态。而在第二阶段作用$C_5=U_4(\theta_1)$时，我们发现$L_5$的第二个元素不为空，为$\theta_1$，因此，我们将$V_1[1]$append当前缓存下来的态。</p><p>在求期望值关于某个参数的梯度时，我们还需要一个列表$Q’$，指明参数的分割的开始和结束，实际上是$Q$的简化版：</p><script type="math/tex; mode=display">\begin{aligned}Q'_1&=[[2,5],[12,13]]\\Q'_2&=[[3,4]]\\Q'_3&=[[9,10]]\\\end{aligned}</script><p>有了$L$和$M=Q’$，则在计算梯度中将方便很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推导对含参数的量子线路的求导。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="泡利算符" scheme="https://github.com/donghufeng/tags/%E6%B3%A1%E5%88%A9%E7%AE%97%E7%AC%A6/"/>
    
      <category term="旋转算符" scheme="https://github.com/donghufeng/tags/%E6%97%8B%E8%BD%AC%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>用python绘制blender图形</title>
    <link href="https://github.com/donghufeng/2020/03/31/%E7%94%A8python%E7%BB%98%E5%88%B6blender%E5%9B%BE%E5%BD%A2/"/>
    <id>https://github.com/donghufeng/2020/03/31/%E7%94%A8python%E7%BB%98%E5%88%B6blender%E5%9B%BE%E5%BD%A2/</id>
    <published>2020-03-31T10:51:00.000Z</published>
    <updated>2020-03-31T10:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用<code>python</code>来进行blender建模。<br><a id="more"></a></p><p>TODO: 利用blender来进行科学研究中的绘图美化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="comment"># mesh arrays</span></span><br><span class="line">verts = []</span><br><span class="line">faces = []</span><br><span class="line">edges = []</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3D supershape parameters</span></span><br><span class="line">m = <span class="number">14.23</span></span><br><span class="line">a = <span class="number">-0.06</span></span><br><span class="line">b = <span class="number">2.78</span></span><br><span class="line">n1 = <span class="number">0.5</span></span><br><span class="line">n2 = <span class="number">-.48</span></span><br><span class="line">n3 = <span class="number">1.5</span></span><br><span class="line"> </span><br><span class="line">scale = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">Unum = <span class="number">50</span></span><br><span class="line">Vnum = <span class="number">50</span></span><br><span class="line"> </span><br><span class="line">Uinc = math.pi / (Unum/<span class="number">2</span>)</span><br><span class="line">Vinc = (math.pi/<span class="number">2</span>)/(Vnum/<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#fill verts array</span></span><br><span class="line">theta = -math.pi</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, Unum + <span class="number">1</span>):</span><br><span class="line">    phi = -math.pi/<span class="number">2</span></span><br><span class="line">    r1 = <span class="number">1</span>/(((abs(math.cos(m*theta/<span class="number">4</span>)/a))**n2+(abs(math.sin(m*theta/<span class="number">4</span>)/b))**n3)**n1)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,Vnum + <span class="number">1</span>):</span><br><span class="line">        r2 = <span class="number">1</span>/(((abs(math.cos(m*phi/<span class="number">4</span>)/a))**n2+(abs(math.sin(m*phi/<span class="number">4</span>)/b))**n3)**n1)</span><br><span class="line">        x = scale * (r1 * math.cos(theta) * r2 * math.cos(phi))</span><br><span class="line">        y = scale * (r1 * math.sin(theta) * r2 * math.cos(phi))</span><br><span class="line">        z = scale * (r2 * math.sin(phi))</span><br><span class="line"> </span><br><span class="line">        vert = (x,y,z) </span><br><span class="line">        verts.append(vert)</span><br><span class="line">        <span class="comment">#increment phi</span></span><br><span class="line">        phi = phi + Vinc</span><br><span class="line">    <span class="comment">#increment theta</span></span><br><span class="line">    theta = theta + Uinc</span><br><span class="line"> </span><br><span class="line"><span class="comment">#fill faces array</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, (Vnum + <span class="number">1</span>) *(Unum)):</span><br><span class="line">    <span class="keyword">if</span> count &lt; Vnum:</span><br><span class="line">        A = i</span><br><span class="line">        B = i+<span class="number">1</span></span><br><span class="line">        C = (i+(Vnum+<span class="number">1</span>))+<span class="number">1</span></span><br><span class="line">        D = (i+(Vnum+<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">        face = (A,B,C,D)</span><br><span class="line">        faces.append(face)</span><br><span class="line"> </span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#create mesh and object</span></span><br><span class="line">mymesh = bpy.data.meshes.new(<span class="string">"supershape"</span>)</span><br><span class="line">myobject = bpy.data.objects.new(<span class="string">"supershape"</span>,mymesh)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#set mesh location</span></span><br><span class="line">myobject.location = bpy.context.scene.cursor.location</span><br><span class="line">bpy.context.collection.objects.link(myobject)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#create mesh from python data</span></span><br><span class="line">mymesh.from_pydata(verts,edges,faces)</span><br><span class="line">mymesh.update(calc_edges=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#set the object to edit mode</span></span><br><span class="line"><span class="comment">#bpy.context.scene.objects.active = myobject</span></span><br><span class="line"><span class="comment">#obj = bpy.context.window.scene.objects[0]</span></span><br><span class="line">bpy.context.view_layer.objects.active = myobject</span><br><span class="line">bpy.ops.object.mode_set(mode=<span class="string">'EDIT'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># remove duplicate vertices</span></span><br><span class="line">bpy.ops.mesh.remove_doubles() </span><br><span class="line"> </span><br><span class="line"><span class="comment"># recalculate normals</span></span><br><span class="line">bpy.ops.mesh.normals_make_consistent(inside=<span class="literal">False</span>)</span><br><span class="line">bpy.ops.object.mode_set(mode=<span class="string">'OBJECT'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># subdivide modifier</span></span><br><span class="line">myobject.modifiers.new(<span class="string">"subd"</span>, type=<span class="string">'SUBSURF'</span>)</span><br><span class="line">myobject.modifiers[<span class="string">'subd'</span>].levels = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># show mesh as smooth</span></span><br><span class="line">mypolys = mymesh.polygons</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> mypolys:</span><br><span class="line">    p.use_smooth = <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用&lt;code&gt;python&lt;/code&gt;来进行blender建模。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="blender" scheme="https://github.com/donghufeng/tags/blender/"/>
    
  </entry>
  
  <entry>
    <title>新机配置流程</title>
    <link href="https://github.com/donghufeng/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/donghufeng/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</id>
    <published>2020-03-29T16:05:57.000Z</published>
    <updated>2020-03-31T10:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>新机器配置过程。<br><a id="more"></a></p><h1 id="装机流程"><a href="#装机流程" class="headerlink" title="装机流程"></a>装机流程</h1><ul><li>安装pip</li></ul><p><code>sudo apt install python3-pip</code></p><ul><li>生存ssh密钥</li></ul><p><code>ssh-keygen -t rsa -C &quot;your@email&quot;</code></p><ul><li><p>下载vscode</p></li><li><p>下载setting-sync插件</p></li></ul><p>Gist id: e7084f25b33de90bddd1a98977971d41</p><p>token: xxxx</p><ul><li>免费ssr</li></ul><p>ssr://NDUuMTM2LjI0NC4yMDU6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6Wkdab1oyWnE</p><p>ssr://NDUuMTI5LjMuMTMxOjQ0MzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jdHI6dGxzMS4yX3RpY2tldF9hdXRoOmFtaGtaMmhrWm1j</p><p>ssr://NDUuMTI5LjMuNTc6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6WjJabmFHZG1jMlJvYVd0cWVYVnlaUQ</p><p>ssr下载地址：</p><ol><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf</a></p></li><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc</a></p></li></ol><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><ol><li>安装ss客户端</li></ol><p><code>pip install git+https://github.com/shadowsocks/shadowsocks.git@master</code></p><ol><li>ss配置文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"XXXXXXX"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: XXXXXX,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"XXXXXX"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"aes-256-gcm"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地地址为<code>127.0.0.1</code>，端口为<code>1080</code>。</p><ol><li>启动ss</li></ol><p><code>sslocal -c /xxx/xxx/sslocal-config.json &amp;</code></p><h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><p>ss是socks5协议，需要做http转发，供整个系统使用</p><ol><li>安装privoxy</li></ol><p><code>sudo apt install privoxy</code></p><ol><li>配置privoxy</li></ol><p>在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen-address 127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>表示privoxy对本机的代理端口为<code>8118</code>。</p><p>如果需要全局代理，则在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的http请求都使用本机的1080端口的socks5协议来转发。</p><p>如果需要局部代理，则注释掉上面全局代理的那行，加上：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 .google.com 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的<code>.google.com</code>的http请求都从本机的1080端口转发，而其他的网站则不做代理。</p><p>同时也可以通过文件的方式制定更多的网站代理。复制<code>gfwlist.action</code>到<code>/etc/privoxy</code>目录下，并在该目录下的设置文件<code>config</code>中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionsfile gfwlist.action</span><br></pre></td></tr></table></figure><p>表明该文件中的网站都做代理。</p><ol><li>启动privoxy</li></ol><p><code>sudo service privoxy start</code></p><p>该命令是开机自动启动，因此下次开机不需要运行。</p><ol><li>设置本机代理</li></ol><p>在本机的网络代理设置中选择手动配置代理服务器，将本机的http请求都通过privoxy来代理。对所有协议都选择地址为<code>127.0.0.1</code>端口为<code>8118</code>。</p><ol><li>终端也能利用ss</li></ol><p>对终端的网络也设置代理，在全局变量中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="variable">$proxy</span></span><br></pre></td></tr></table></figure><p>可在<code>～/.bashrc</code>或者<code>/etc/profile</code>中添加上述指令。</p><p>梳理一下流程，通过设置本机代理，将本机的所有<code>http</code>请求都利用<code>privoxy</code>来进行转发。<code>privoxy</code>则根据规则选择性地将http请求转为shadowsocks的socks5协议向目标网站获得数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新机器配置过程。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://github.com/donghufeng/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>python - 类</title>
    <link href="https://github.com/donghufeng/2020/03/21/python-%E7%B1%BB/"/>
    <id>https://github.com/donghufeng/2020/03/21/python-%E7%B1%BB/</id>
    <published>2020-03-21T07:32:00.000Z</published>
    <updated>2020-03-30T13:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍python面向对象编程时的一些方法。<br><a id="more"></a></p><h2 id="抽象方法、类方法和静态方法"><a href="#抽象方法、类方法和静态方法" class="headerlink" title="抽象方法、类方法和静态方法"></a>抽象方法、类方法和静态方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""person</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setdoc</span><span class="params">(cls,doc)</span>:</span></span><br><span class="line">        cls.__doc__=doc</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"hi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">woman</span><span class="params">(person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    woman</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        person.__init__(self)</span><br><span class="line">        self.sex=<span class="string">'woman'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line">alice=woman()</span><br><span class="line"></span><br><span class="line"><span class="comment"># staticmethod</span></span><br><span class="line">alice.sayhi() <span class="comment">#hi</span></span><br><span class="line">woman.sayhi() <span class="comment">#hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classmethod</span></span><br><span class="line">print(alice.__doc__) <span class="comment">#woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#woman</span></span><br><span class="line">alice.setdoc(<span class="string">"set by alice"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">woman.setdoc(<span class="string">"set by woman"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by woman</span></span><br><span class="line"><span class="comment"># %%</span></span><br></pre></td></tr></table></figure><p><code>@abstractmethod</code>:</p><p>必须被子类重新实现，否者在实例化时就会报错</p><p><code>@classmethod</code>:</p><p>类方法可通过实例调用，也可通过类直接调用，改变的是类本身的参数，类方法的第一个关键字是cls</p><p><code>@staticmethod</code></p><p>静态方法，可通过类本身或者实例来调用，不会改变类或者实例本身的任何东西，但是该方法隶属于该类，这么写是为了方便代码组织。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍python面向对象编程时的一些方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/donghufeng/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="抽象方法" scheme="https://github.com/donghufeng/tags/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    
      <category term="类方法" scheme="https://github.com/donghufeng/tags/%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="静态方法" scheme="https://github.com/donghufeng/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Quantum Chemistry - Basic</title>
    <link href="https://github.com/donghufeng/2020/03/20/Quantum-Chemistry-Basic/"/>
    <id>https://github.com/donghufeng/2020/03/20/Quantum-Chemistry-Basic/</id>
    <published>2020-03-20T05:47:31.000Z</published>
    <updated>2020-03-20T07:47:53.690Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Modern Quantum Chemistry</em>.<br>基本知识。</p><a id="more"></a><h2 id="原子单位"><a href="#原子单位" class="headerlink" title="原子单位"></a>原子单位</h2><p>原子单位是为了进行无量纲处理。氢原子的电子波动方程可写为：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e}\nabla^2-\frac{e^2}{4\pi\varepsilon_0r}\right]\phi=E\phi</script><p>对长度进行无量纲化，取$r=\lambda r’$，代入上式可得：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e \lambda^2}\nabla'^2-\frac{e^2}{4\pi\varepsilon_0r'\lambda}\right]\phi=E\phi</script><p>令:</p><script type="math/tex; mode=display">\frac{\hbar^2}{m_e \lambda^2}=\frac{e^2}{4 \pi \varepsilon_0 \lambda}=E_a</script><p>称$E_a$为一个<em>Hartree</em>，约为$27.211\text{eV}$，由上式可得：</p><script type="math/tex; mode=display">\lambda=\frac{4 \pi\varepsilon_0 \hbar^2}{m_e e^2}=a_0</script><p>称$a_0$为玻尔半径，约为0.52918埃。经过单位转化过后，薛定谔方程变为：</p><script type="math/tex; mode=display">\left(-\frac{1}{2} \nabla'^2-\frac{1}{r'}\right)\phi'=E'\phi'</script><p>因此在原子单位里，能力的单位为一个Hartree $E_a$，长度的单位为一个波尔半径$a_0$。</p><h2 id="多体相互作用哈密顿量"><a href="#多体相互作用哈密顿量" class="headerlink" title="多体相互作用哈密顿量"></a>多体相互作用哈密顿量</h2><p>对于$M$个原子和$N$个电子的系统，其哈密顿量在原子单位下可写为：</p><script type="math/tex; mode=display">\begin{aligned}H&=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{A=1}^{M}\frac{1}{2M_A}\nabla _{A}^{2}-\sum_{i=1}^{M}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}\\&+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}\end{aligned}</script><h2 id="电子哈密顿量"><a href="#电子哈密顿量" class="headerlink" title="电子哈密顿量"></a>电子哈密顿量</h2><p>由于原子比电子重很多，因此可以近似认为原子是不动的，只有电子在原子所形成的场中运动，那么原子的动能将为被忽略，而原子之间的相互作用将为常数，因此哈密顿量可以简化为：</p><script type="math/tex; mode=display">H_\text{elec}=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{i=1}^{N}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}</script><p>并称其为电子哈密顿量。设其本征值为$E_\text{elec}$，那么系统总能量是电子能量和原子排斥能之和，则为：</p><script type="math/tex; mode=display">E_ \text{tot}=E_ \text{elec}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}</script><h2 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h2><p>电子具有$1/2$自旋，因此电子的坐标是由位置坐标和自旋方向构成：</p><script type="math/tex; mode=display">x=\{r,w\}</script><p>泡利不相容原理说，电子波函数中，交换两个电子不能同时处于同意空间位置，因此有：</p><script type="math/tex; mode=display">\Phi \left(x_1,\cdots,x_i,\cdots,x_j,\cdots,x_n\right)=-\Phi \left(x_1,\cdots,x_j,\cdots,x_i,\cdots,x_n\right)</script><h2 id="单电子波函数"><a href="#单电子波函数" class="headerlink" title="单电子波函数"></a>单电子波函数</h2><p>单电子波函数由空间波函数和自旋波函数构成：</p><script type="math/tex; mode=display">\chi(x)=\psi(r) \left|+\right> \text{or } \psi(r) \left|-\right></script><p>对于多电子哈密顿量来说，如果忽略电子之间的排斥力，则多电子波函数是单电子波函数的乘积构成，称为<strong>Hartree Product</strong>。但是该波函数不满足泡利反对称性，因此需要通过如下方法构造。</p><h2 id="Slater-Determinats"><a href="#Slater-Determinats" class="headerlink" title="Slater Determinats"></a>Slater Determinats</h2><p>联想到在矩阵求秩时，任意交换两行则秩会反号，因此可通过求单电子波函数构成的矩阵的秩的方法来求多电子波函数的满足反对称性的波函数。</p><script type="math/tex; mode=display">\Psi(x_1,\cdots,x_N)=\frac{1}{\sqrt{N!}} \begin{vmatrix}\chi_i(x_1)&\chi_j(x_1)&\cdots&\chi_k(x_1)\\\chi_i(x_2)&\chi_j(x_2)&\cdots&\chi_k(x_2)\\\vdots&\vdots&&\vdots\\\chi_i(x_N)&\chi_j(x_N)&\cdots&\chi_k(x_N)\end{vmatrix}</script><p>并简写为：</p><script type="math/tex; mode=display">\Psi= \left|\chi_i\chi_j\cdots\chi_k\right></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Modern Quantum Chemistry&lt;/em&gt;.&lt;br&gt;基本知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Quantum Chemistry" scheme="https://github.com/donghufeng/categories/Quantum-Chemistry/"/>
    
    
      <category term="计算化学" scheme="https://github.com/donghufeng/tags/%E8%AE%A1%E7%AE%97%E5%8C%96%E5%AD%A6/"/>
    
      <category term="原子单位" scheme="https://github.com/donghufeng/tags/%E5%8E%9F%E5%AD%90%E5%8D%95%E4%BD%8D/"/>
    
      <category term="Hartree" scheme="https://github.com/donghufeng/tags/Hartree/"/>
    
      <category term="波尔半径" scheme="https://github.com/donghufeng/tags/%E6%B3%A2%E5%B0%94%E5%8D%8A%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 阶查找</title>
    <link href="https://github.com/donghufeng/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
    <id>https://github.com/donghufeng/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/</id>
    <published>2020-03-19T04:05:18.000Z</published>
    <updated>2020-03-19T04:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子阶查找算法。<br><a id="more"></a></p><h2 id="阶查找算法"><a href="#阶查找算法" class="headerlink" title="阶查找算法"></a>阶查找算法</h2><p>对于两个正整数 $x,N,x&lt;N $，该算法能找到最小的整数$r$，且满足$x^r=1(\text{mod } N)$。利用相位估计算法可以近似求解改问题。</p><p>假设有酉算符满足：</p><script type="math/tex; mode=display">U \left|y\right>=\left|xy(\text{mod }N)\right></script><p>$U$的本征态为$\left|u_s\right&gt;$，且有：</p><script type="math/tex; mode=display">\left|u_s\right>=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right></script><p>下面证明改态确实是$U$的本征态。</p><script type="math/tex; mode=display">\begin{aligned}U \left|u_s\right>&=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\\&=e^{2\pi is/r}\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is (k+1)}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\end{aligned}</script><p>又因为：</p><script type="math/tex; mode=display">\exp \left[\frac{-2\pi is r}{r}\right]\left|x^r(\text{mod }N)\right>=\left|1(\text{mod }N)\right>=\exp \left[\frac{-2\pi is 0}{r}\right]\left|x^0(\text{mod }N)\right></script><p>所以：</p><script type="math/tex; mode=display">U \left|u_s\right>=\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right></script><p>因此，可以利用相位估计算法，得到$s/r$，并计算得到阶数$r$。然而，在相位估计算法中，第二个寄存器所需要构造的态$\left|u_s\right&gt;$中已经包含$r$，这不合理。注意到：</p><script type="math/tex; mode=display">\begin{aligned}\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_s\right>&=\frac{1}{r}\sum_{k=0}^{r-1}\sum_{s=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{k0}\left|x^k(\text{mod }N)\right>\\&=\left|1\right>\end{aligned}</script><p>可以将第二个寄存器的处态制备为全$\left|1\right&gt;$，此时：</p><script type="math/tex; mode=display">\begin{aligned}U \left|1\right>&=\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right>\\&=\frac{1}{r}\sum_{s=0}^{r-1}\sum_{k=0}^{r-1}\exp \left[\frac{2\pi is(1-k)}{r}\right] \left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{1k} \left|x^k(\text{mod }N)\right>\\&=\left|x\right>\end{aligned}</script><blockquote><p>此处存疑，$\left|1\right&gt;$不是$U$的本征态！相位估计该怎么做？？？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子阶查找算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="阶查找" scheme="https://github.com/donghufeng/tags/%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 相位估计</title>
    <link href="https://github.com/donghufeng/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/"/>
    <id>https://github.com/donghufeng/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/</id>
    <published>2020-03-18T09:37:48.000Z</published>
    <updated>2020-03-19T00:37:33.739Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子相位估计算法。<br><a id="more"></a></p><h2 id="相位估计问题"><a href="#相位估计问题" class="headerlink" title="相位估计问题"></a>相位估计问题</h2><p>假设有酉算符$U$，其本征态为$\left|u\right&gt;$，对应的本征值为$e^{2\pi i\varphi}$，相位估计算法可以对$\varphi$进行指定精度的估计，注意，这里$0\le\varphi\le1$。改算法第一个步骤的线路图如下：</p><p><img src="/img/pe.png" alt="相位估计"></p><p>图中上半部分的寄存器由$t$个比特构成，下半部分的寄存器存储的是本征态$\left|u\right&gt;$。首先对第一个寄存器作用$H^{\otimes t}$，然后依次选择第$j$个比特对第二个寄存器做受控$U^{2^j-1}$操作。因此第一个寄存器的态为：</p><script type="math/tex; mode=display">H^{\otimes t}\left|0\right>^{\otimes t}=\frac{1}{\sqrt{2^t}}\sum_j \left|j\right>=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1}\left|j_1\cdots j_{t}\right></script><p>作用第一个控制门：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_1\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t-1}=0}^{1} \left|j_1\cdots j_{t-1}\right>\left(\left|0\right>+e^{2\pi i \varphi(2^0 )}\left|1\right>\right)\\&=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第二个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_2\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{t-1}2^1+j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第$t$个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_{t}\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{1}2^{t-1}+j_t 2^0)}\left|j_1\cdots j_{t}\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi j}\left|j\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi\cdot 2^t j/2^t}\left|j\right>\end{aligned}</script><p>可见第一个寄存器的末态是对$\left|2^t\varphi\right&gt;$进行傅里叶变换得到的，因此，如果$\varphi$可以写为$\varphi=0.\varphi_1\cdots\varphi_t$时，对其作用傅里叶逆变换将得到$\varphi$的精确值。如果不能精确写出此形式，则可以在$2^{-n}$的精确度下近似得到$\varphi$，此时所需的比特数为：</p><script type="math/tex; mode=display">t=n+\left\lceil\log \left(2+\frac{1}{2\epsilon}\right)\right\rceil.</script><p>整体的线路图为：</p><p><img src="/img/pe2.png" alt="相位估计2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子相位估计算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="相位估计" scheme="https://github.com/donghufeng/tags/%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>拍平一个矩阵</title>
    <link href="https://github.com/donghufeng/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/"/>
    <id>https://github.com/donghufeng/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-16T08:17:04.000Z</published>
    <updated>2020-03-16T14:40:46.656Z</updated>
    
    <content type="html"><![CDATA[<p>如何拍平一个矩阵？<br><a id="more"></a></p><ul><li><code>x.flatten</code></li><li><code>x.revel</code></li><li><code>x.reshape(-1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何拍平一个矩阵？&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/donghufeng/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="技巧" scheme="https://github.com/donghufeng/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 各种分解</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/</id>
    <published>2020-03-16T05:28:14.000Z</published>
    <updated>2020-03-16T15:09:59.056Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍矩阵的各种分解。<br><a id="more"></a></p><h2 id="极分解-Polar-decomposition"><a href="#极分解-Polar-decomposition" class="headerlink" title="极分解(Polar decomposition)"></a>极分解(Polar decomposition)</h2><p>对于$V$空间中的任意算符$A$，能将其按照如下形式分解</p><script type="math/tex; mode=display">A=UJ=KU</script><p>其中，$U$为酉矩阵，且$J$为半正定矩阵，$J=\sqrt{A^\dagger A}$，$K=\sqrt{AA^\dagger}$，如果$A$可逆，则$U$唯一。<br><strong>证明：</strong></p><ol><li>取$V$空间的一组基矢$\left|i\right&gt;$和任意态$\left|v\right&gt;$，则：<script type="math/tex; mode=display">\left<v\right|A^\dagger A \left|v\right>=\sum_i\left|a_i\right|^2\ge 0</script>因此$A^\dagger A$是对称半正定矩阵，$\sqrt{A^\dagger A}$也是对称半正定矩阵。</li><li>根据谱定理，对于半正定矩阵有：<br><script type="math/tex">J=\sqrt{A^\dagger A}=\sum_i \lambda_i \left|i\right>\left<i\right|(\lambda_i\ge0)</script>。</li><li>定义$\left|\psi_i\right&gt;=A \left|i\right&gt;$，因此有：<br><script type="math/tex">\left<\psi_i\mid \psi_i\right>=\left<i\right|A^\dagger A\left|i\right>=\lambda_i^2</script>。</li><li>对于$\lambda_i\neq 0$的态，定义$\left|e_i\right&gt;=\left|\psi_i\right&gt;/\lambda_i$，因此$\left|e_i\right&gt;$是彼此正交的单位矢量。</li><li>利用Schmidt正交化方法对$\left|e_i\right&gt;$进行扩充，使得其为$V$中的基矢，并仍然记为$\left|e_i\right&gt;$。</li><li>定义酉算符$U=\sum_i \left|e_i\right&gt;\left&lt;i\right|$。</li><li>对于$\lambda_i\neq 0$的那些态，有<br><script type="math/tex">UJ \left|i\right>=\lambda_i U \left|i\right>=\lambda_i \left|e_i\right>=\left|\psi_i\right>=A \left|i\right></script>。</li><li>对于$\lambda_i =0$的态来说，有<script type="math/tex; mode=display">UJ \left|i\right>=0=\left|\psi_i\right>=A \left|i\right></script></li></ol><p>综上，$A=UJ$。此时，$A=UJ=UJU^\dagger U=KU$，且$K=UJU^\dagger=K^\dagger$，此时</p><script type="math/tex; mode=display">AA^\dagger=KUU^\dagger K^\dagger=K^2</script><p>所以$K=\sqrt{AA^\dagger}$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>对于任意方矩阵，总可以按照如下分解，</p><script type="math/tex; mode=display">A=UDV</script><p>其中，$U$和$V$是酉矩阵，$D$是对角矩阵，称为$A$的奇异值。<br><strong>证明：</strong></p><ol><li>根据极分解，$A=SJ$，其中$S$为酉矩阵，$J$为半正定矩阵。</li><li>根据谱分解定理，$J=TDT^\dagger$，其中$T$为酉矩阵，$D$为对角矩阵。</li><li>由上：<script type="math/tex; mode=display">A=SJ=STDT^\dagger</script></li></ol><p>因此有$U=ST$，$V=T^\dagger$。</p><h2 id="Schmidt分解"><a href="#Schmidt分解" class="headerlink" title="Schmidt分解"></a>Schmidt分解</h2><p>复合系统$AB$中的纯态$ \left|\psi\right&gt; $总能按如下分解：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_i \lambda_i \left|i_A\right> \left|i_B\right></script><p>其中$ \left|i_A\right&gt; $和$ \left|i_B\right&gt; $分别为两个子系统的正交归一基矢，且$\lambda_i$是正实数，满足归一化条件$\sum_i\lambda_i^2=1$。</p><p><strong>证明：</strong></p><p>这里假设两个子系统的空间维度一样，并且取两个子系统的任意正交归一基矢为$ \left|j\right&gt; $和$ \left|k\right&gt; $，则复合空间$AB$中的纯态$ \left|\psi\right&gt; $可按照子空间的基矢展开：</p><script type="math/tex; mode=display">\left|\psi\right> =\sum_{jk}a_{jk} \left|j\right> \left|k\right></script><p>系数矩阵$a$为方阵，可进行奇异值分解$a=udv$，因此：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_{ijk} u_{ji}d_{ii}v_{ik}\left|j\right> \left|k\right></script><p>令$ \left|i_A\right&gt;=\sum_ju_{ji} \left|j\right&gt;, \left|i_B\right&gt;=\sum_k v_{ik} \left|k\right&gt;, \lambda_i=d_{ii} $，即可得到满足条件的分解。此时有</p><script type="math/tex; mode=display">\begin{aligned}    \rho^A&=\text{tr}_B(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_A\right>\left<i_A\right|\\    \rho^B&=\text{tr}_A(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_B\right>\left<i_B\right|\end{aligned}</script><p>易知，$ \left|i_X\right&gt; $为纯态$ \left|\psi\right&gt; $在子系统$X$中的约化密度矩阵$\rho^X$的本征态，$\lambda_i^2$为两个子系统约化密度矩阵的共同本征值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;介绍矩阵的各种分解。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="极分解" scheme="https://github.com/donghufeng/tags/%E6%9E%81%E5%88%86%E8%A7%A3/"/>
    
      <category term="奇异值分解" scheme="https://github.com/donghufeng/tags/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    
      <category term="Schmidt分解" scheme="https://github.com/donghufeng/tags/Schmidt%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 密度算符与迹</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/</id>
    <published>2020-03-16T05:24:20.000Z</published>
    <updated>2020-03-16T05:27:09.083Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>记录零碎知识点。<br><a id="more"></a></p><h2 id="密度矩阵"><a href="#密度矩阵" class="headerlink" title="密度矩阵"></a>密度矩阵</h2><p>混态不能用一个态标识出来，系统中出现态$\left|\psi_i\right&gt;$的概率为$p_i$，密度矩阵可写为：</p><script type="math/tex; mode=display">\rho=\sum_i^np_i \left|\psi_i\right>\left<\psi_i\right|</script><p>这里当$n=1$是为纯态密度矩阵。可观察量$A$在混态中的期望值为：</p><script type="math/tex; mode=display">E(A)=\sum_i^n p_i \left<\psi_i\right|A\left|\psi_i\right>=\text{tr}(\rho A)</script><p>纯态也有相同结果 。</p><p>混态的$\text{tr}(\rho^2)&lt;1$：</p><script type="math/tex; mode=display">\text{tr}(\rho^2)=\sum_{i,j}p_j^2 \left<i\mid \psi_j\right> \left<\psi_j\mid i\right>\le\sum_i p_i^2<\sum_i p_i=1</script><p>对于纯态来说：</p><script type="math/tex; mode=display">\left|\psi\right>=\cos\frac{\theta}{2} \left|0\right>+e^{i\varphi}\sin{\frac{\theta}{2}} \left|1\right></script><p>其密度矩阵为：</p><script type="math/tex; mode=display">\begin{aligned}\rho&= \left|\psi\right>\left<\psi\right|\\&= \begin{pmatrix}\cos^2\frac{\theta}{2}&\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{-i\varphi}\\\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{i\varphi}&\sin^2\frac{\theta}{2}\end{pmatrix}\\&= \frac{1}{2}\begin{pmatrix}1+\cos\theta&\sin\theta e^{-i\varphi}\\\sin\theta e^{i\varphi}&1-\cos\theta\end{pmatrix}\\&=\frac{I+\vec{r}\cdot \vec{\sigma}}{2}\end{aligned}</script><p>对于混态来说，有$\rho=\sum_i p_i \rho_i$，因此，也有上述的形式。</p><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><p>对于任意算符$A$，和一组正交基矢$\left|i\right&gt;$,迹的定义为：</p><script type="math/tex; mode=display">\text{tr}(A)=\sum_i \left<i\right|A\left|i\right>=\sum_i A_{ii}</script><p>取任意态$\left|\psi\right&gt;$，则有$\text{tr}(A \left|\psi\right&gt;\left&lt;\psi\right|)=\left&lt;\psi\right|A\left|\psi\right&gt;$，证明如下：</p><script type="math/tex; mode=display">\text{tr}(A \left|\psi\right>\left<\psi\right|)=\sum_i \left<i\right|A\left|\psi\right> \left<\psi\mid i\right>=\sum_i  \left<\psi\mid i\right>\left<i\right|A\left|\psi\right>=\left<\psi\right|A\left|\psi\right></script><h2 id="约化密度矩阵和偏迹"><a href="#约化密度矩阵和偏迹" class="headerlink" title="约化密度矩阵和偏迹"></a>约化密度矩阵和偏迹</h2><script type="math/tex; mode=display">\rho^A=\text{tr}_B(\rho^{AB})</script><p>e.g.:</p><script type="math/tex; mode=display">\text{tr}_B(\left|a_1\right>\left<a_2\right|\otimes \left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right|\text{tr}(\left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right| \left<b_2\mid b_1\right></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;记录零碎知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="密度矩阵" scheme="https://github.com/donghufeng/tags/%E5%AF%86%E5%BA%A6%E7%9F%A9%E9%98%B5/"/>
    
      <category term="迹" scheme="https://github.com/donghufeng/tags/%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - Cauchy-Schwarz不等式</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/</id>
    <published>2020-03-16T05:19:12.000Z</published>
    <updated>2020-03-16T05:21:52.176Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍Cauchy-Schwarz不等式。<br><a id="more"></a></p><h2 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h2><p>希尔伯特空间中的两个态矢量$\left|v\right&gt;$和$\left|w\right&gt;$，则有：</p><script type="math/tex; mode=display">\left| \left<v\mid w\right>\right|^2\le \left<v\mid v\right> \left<w\mid w\right></script><p><strong>证明：</strong><br>在希尔伯特空间中选择一组基矢$\left|i\right&gt;$，并使得该组基矢的第一个为</p><script type="math/tex; mode=display">\left|w\right>/\sqrt{\left<w\mid w\right>}</script><p>因此：</p><script type="math/tex; mode=display">\begin{aligned}\left<v\mid v\right>\left<w\mid w\right>&=\sum_i \left<v\mid i\right>\left<i\mid v\right>\left<w\mid w\right>\\&\ge\frac{\left<v\mid w\right>\left<w\mid v\right>}{\left<w\mid w\right>}\left<w\mid w\right>\\&=\left|\left<v\mid w\right>\right|^2\end{aligned}</script><p>取$\ge$是因为求和中只取第一个基矢，而忽略掉有剩余基矢得到的数（为正数）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;介绍Cauchy-Schwarz不等式。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Cauchy-Schwarz不等式" scheme="https://github.com/donghufeng/tags/Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo注意事项</title>
    <link href="https://github.com/donghufeng/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://github.com/donghufeng/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-03-16T04:42:52.000Z</published>
    <updated>2020-03-16T05:18:09.315Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用过程中的注意事项。<br><a id="more"></a></p><ul><li>大括号{}问题。</li></ul><p>在公式中，如果要显示”{}”，需要加两个”//“，如$\{\}$。</p><ul><li>量子态问题</li></ul><p>如果一段话中有两个态矢量，且里面的字母有大括号包围的下脚标，需要将”_<em>“改为”\_</em>“，如：</p><p>$\left|a_{0}\right&gt;$b$\left|c_{1}\right&gt;.$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo使用过程中的注意事项。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://github.com/donghufeng/tags/Hexo/"/>
    
  </entry>
  
</feed>
