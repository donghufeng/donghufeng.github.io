<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>东湖风的札记</title>
  
  <subtitle>Keep Learning</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/donghufeng/"/>
  <updated>2020-04-21T11:37:28.649Z</updated>
  <id>https://github.com/donghufeng/</id>
  
  <author>
    <name>xu xusheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux中的一些文件</title>
    <link href="https://github.com/donghufeng/2020/04/21/Linux%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/"/>
    <id>https://github.com/donghufeng/2020/04/21/Linux%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%87%E4%BB%B6/</id>
    <published>2020-04-21T11:17:27.000Z</published>
    <updated>2020-04-21T11:37:28.649Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍Linux中的一些系统文件。</p><a id="more"></a><h2 id="etc-profile"><a href="#etc-profile" class="headerlink" title="/etc/profile"></a><code>/etc/profile</code></h2><p>用户登录时，系统自动运行的文件，可在此文件中加上自动运行的脚本，例如添加环境变量的脚本。</p><h2 id="bashrc"><a href="#bashrc" class="headerlink" title="~/.bashrc"></a><code>~/.bashrc</code></h2><p>用户打开<code>terminal</code>时自动加载的文件。只对当前用户有效。</p><h2 id="etc-fstab"><a href="#etc-fstab" class="headerlink" title="/etc/fstab"></a><code>/etc/fstab</code></h2><p>开机自动挂载硬盘的文件。</p><h2 id="etc-default-grub"><a href="#etc-default-grub" class="headerlink" title="/etc/default/grub"></a><code>/etc/default/grub</code></h2><p>开机系统选择界面设置文件，修改后通过<code>sudo update-grub</code>进行更新。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍Linux中的一些系统文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Note on Quantum Information - 噪声</title>
    <link href="https://github.com/donghufeng/2020/04/19/Note-on-Quantum-Information-%E5%99%AA%E5%A3%B0/"/>
    <id>https://github.com/donghufeng/2020/04/19/Note-on-Quantum-Information-%E5%99%AA%E5%A3%B0/</id>
    <published>2020-04-19T14:32:44.000Z</published>
    <updated>2020-04-19T14:49:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍噪声的基本概念和马尔可夫过程。</p><a id="more"></a><h2 id="经典噪声"><a href="#经典噪声" class="headerlink" title="经典噪声"></a>经典噪声</h2><p>假设某比特初始状态为$a, a\in(0,1)$，进过某个噪声影响后会变成$b, b\in(0,1)$，且有</p><script type="math/tex; mode=display">\begin{aligned}p(b=\bar{a})&=p\\p(b=a)&=1-p\end{aligned}</script><p>则受该噪声影响而产生的态转移为：</p><script type="math/tex; mode=display">\begin{pmatrix}q_0\\q_1\end{pmatrix}=\begin{pmatrix}1-p&p\\p&1-p\end{pmatrix}\begin{pmatrix}p_0\\p_1\end{pmatrix}</script><p>为了使演化前后的概率分布有意义，则状态转移的矩阵需要满足两个性质，1、<code>完备性</code>：矩阵的每列的和都为1；2、<code>正定</code>：矩阵的元素都是0到1之间的数。</p><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><p>假设有两个连续地系统噪声演化，$E_1$和$E_2$，如果此两个噪声没有任何关系，只跟当前系统的状态有关，那么称该过程为马尔可夫过程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍噪声的基本概念和马尔可夫过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子噪声" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%99%AA%E5%A3%B0/"/>
    
      <category term="马尔可夫" scheme="https://github.com/donghufeng/tags/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu 历史补全</title>
    <link href="https://github.com/donghufeng/2020/04/19/ubuntu-%E5%8E%86%E5%8F%B2%E8%A1%A5%E5%85%A8/"/>
    <id>https://github.com/donghufeng/2020/04/19/ubuntu-%E5%8E%86%E5%8F%B2%E8%A1%A5%E5%85%A8/</id>
    <published>2020-04-19T03:40:56.000Z</published>
    <updated>2020-04-19T14:30:07.547Z</updated>
    
    <content type="html"><![CDATA[<p>如何在linux终端中通过调用page up和page down来补全命令。</p><a id="more"></a><p>打开<code>/etc/inputrc</code>，注释掉<code>history-search-backward</code>和<code>history-search-forward</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何在linux终端中通过调用page up和page down来补全命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/categories/linux/"/>
    
    
      <category term="linux" scheme="https://github.com/donghufeng/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>CCSD基础</title>
    <link href="https://github.com/donghufeng/2020/04/14/CCSD%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/donghufeng/2020/04/14/CCSD%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-13T16:05:45.000Z</published>
    <updated>2020-04-13T17:09:39.039Z</updated>
    
    <content type="html"><![CDATA[<p>简单介绍计算分子基态能量的<code>CCSD</code>理论。<br><a id="more"></a></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>如图：<br><img src="/img/ccsd.png" alt="ccsd"></p><p>某个分子可用$n_q=10$个量子比特来描述，其电子数为$n_e=4$。上图为其轨道占据状态。其中有$\text{spin orbital}=10$，且$\text{spatial orbital}=5$，4个电子占据了最低层的空间轨道，未占据的轨道称为虚轨道。</p><h2 id="ccsd越迁"><a href="#ccsd越迁" class="headerlink" title="ccsd越迁"></a>ccsd越迁</h2><p>ccsd只考虑单电子和双电子越迁，不同的越迁可用对应的升降算符表示。对应与上图来说，单电子越迁可写为：</p><script type="math/tex; mode=display">T_1=a_i^\dagger a_j</script><p>当区分不同的电子自旋时，单电子越迁一共有：</p><script type="math/tex; mode=display">\left|T_1\right|=2C^1_\text{occ}C^1_\text{virt}</script><p>双电子越迁的升降算符表达式为：</p><script type="math/tex; mode=display">T_2=a_p^\dagger a_q a_r^\dagger a_s</script><p>可分为两种情况讨论，首先是两个电子的自旋相同，此时的可能性为</p><script type="math/tex; mode=display">2C_\text{virt}^2A_\text{occ}^2</script><p>其次为两个电子的自旋不同，此时可能性为：</p><script type="math/tex; mode=display">(C_\text{occ}^1C_\text{virt}^1)^2</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单介绍计算分子基态能量的&lt;code&gt;CCSD&lt;/code&gt;理论。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子化学" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E5%8C%96%E5%AD%A6/"/>
    
    
      <category term="量子化学" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%8C%96%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>量子线路求导续</title>
    <link href="https://github.com/donghufeng/2020/04/02/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC%E7%BB%AD/"/>
    <id>https://github.com/donghufeng/2020/04/02/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC%E7%BB%AD/</id>
    <published>2020-04-02T04:32:05.000Z</published>
    <updated>2020-04-02T04:36:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>推导对含参数的量子线路的求导。<br><a id="more"></a></p><h2 id="利用缓冲求梯度步骤"><a href="#利用缓冲求梯度步骤" class="headerlink" title="利用缓冲求梯度步骤"></a>利用缓冲求梯度步骤</h2><p>假设有哈密顿量$H$和含参数的线路$C$，则待优化的可观察量为：</p><script type="math/tex; mode=display">E(\theta)=\left<\psi_0\right|C^\dagger HC\left|\psi_0\right></script><p>还是以上面的量子线路为例：</p><script type="math/tex; mode=display">C(\theta_1,\theta_2,\theta_3)=XXU_1(\theta_1)U_2(\theta_1,\theta_2)U_3(\theta_2)U_4(\theta_1)XXXU_5(\theta_3)U_6(\theta_3)XU_7(\theta_1)U_8(\theta_1)XX</script><p>并采用分割：</p><script type="math/tex; mode=display">\begin{aligned}Q_1&=\{\{2,3,5\},\{12,13\}\}\\Q_2&=\{\{3,4\}\}\\Q_3&=\{\{9,10\}\}\end{aligned}</script><p>当求期望值对$\theta_1$的导数时，对于$Q_1$的第一个子集，我们需要缓冲下来的态为：</p><script type="math/tex; mode=display">C_{[0,1]}\left|\psi_0\right>,\left<\psi_0\right|C^\dagger H C_{[6,15]}</script><p>其中$C_{[a,b]}$表示线路的第$a$个门到第$b$个门，当其作用在右矢上时，是从左向右选择线路上的门依次作用，当其作用在左矢上时，是从右向左选择线路上的门依次作用。</p><p>对于一般情况，如何在期望值的首次演化过程中缓存下对应他态，供求梯度使用呢？</p><h3 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a><strong>第一阶段</strong></h3><p>在作用哈密顿量之前，也即在演化$C \left|\psi_0\right&gt;$阶段时，判断当前准备作用的门是否为某个参数的某个分割的开始，如果有，则先缓存下现阶段的量子态，如当作用$U_1(\theta_1)$时，其为量子线路中的第2个门，而第二个门刚好是$\theta_1$参数的第一个分割的开始，因此，需要缓存下还未作用第2个门时的量子态。</p><h3 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a><strong>第二阶段</strong></h3><p>在作用哈密顿量之后，也即在演化$C^\dagger H C \left|\psi_0\right&gt;$时，判断当前准备作用的门是否为某个参数的某个分割的结束，如果有，则先作用该门，然后再缓存下量子态。</p><p>为了求梯度时读取缓存态方便，我们构造一个存储缓存态的结构：</p><script type="math/tex; mode=display">V=[V_1,V_2,V_3],V_1=[[\times,\times],[\times,\times]]</script><p>这里$\left|V_i[j]\right|=\left|Q_i\right|,\left|V_i\right|=2$，$V_i[0][j]$表示分割$Q_{i,j}$在<strong>第一阶段</strong>时缓存的态，$V_i[1][j]$表示分割$Q_{i,\left|Q_i\right|-1-j}$在<strong>第二阶段</strong>时缓存的态。</p><p>为了方便，我们还需要生成一个用于查找当前门是否为某个参数的某个分割的开始或者某个参数的某个分割结束的列表$L$，其结构可写为：</p><script type="math/tex; mode=display">L=[L_0,\cdots,L_{15}],L_0=[[],[]],\cdots,L_2=[[\theta_1],[]],\cdots,L_4=[[],[\theta_4]]</script><p>这里$\left|L\right|=\left| C\right|$，$L_i$有两个元素，第一个元素表示当前门是哪些参数的某个分割的开始，第二个元素表示当前门是哪些参数的某个分割的结束。如当第一阶段作用$C_2=U_1(\theta_1)$时，我们发现$L_2$的第一个元素不为空，为$\theta_1$，因此，我们将$V_1[0]$append当前缓存下来的态。而在第二阶段作用$C_5=U_4(\theta_1)$时，我们发现$L_5$的第二个元素不为空，为$\theta_1$，因此，我们将$V_1[1]$append当前缓存下来的态。</p><p>在求期望值关于某个参数的梯度时，我们还需要一个列表$Q’$，指明参数的分割的开始和结束，实际上是$Q$的简化版：</p><script type="math/tex; mode=display">\begin{aligned}Q'_1&=[[2,5],[12,13]]\\Q'_2&=[[3,4]]\\Q'_3&=[[9,10]]\\\end{aligned}</script><p>有了$L$和$M=Q’$，则在计算梯度中将方便很多。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;推导对含参数的量子线路的求导。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="泡利算符" scheme="https://github.com/donghufeng/tags/%E6%B3%A1%E5%88%A9%E7%AE%97%E7%AC%A6/"/>
    
      <category term="旋转算符" scheme="https://github.com/donghufeng/tags/%E6%97%8B%E8%BD%AC%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>用python绘制blender图形</title>
    <link href="https://github.com/donghufeng/2020/03/31/%E7%94%A8python%E7%BB%98%E5%88%B6blender%E5%9B%BE%E5%BD%A2/"/>
    <id>https://github.com/donghufeng/2020/03/31/%E7%94%A8python%E7%BB%98%E5%88%B6blender%E5%9B%BE%E5%BD%A2/</id>
    <published>2020-03-31T10:51:00.000Z</published>
    <updated>2020-03-31T10:56:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>利用<code>python</code>来进行blender建模。<br><a id="more"></a></p><p>TODO: 利用blender来进行科学研究中的绘图美化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bpy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"> </span><br><span class="line"><span class="comment"># mesh arrays</span></span><br><span class="line">verts = []</span><br><span class="line">faces = []</span><br><span class="line">edges = []</span><br><span class="line"> </span><br><span class="line"><span class="comment">#3D supershape parameters</span></span><br><span class="line">m = <span class="number">14.23</span></span><br><span class="line">a = <span class="number">-0.06</span></span><br><span class="line">b = <span class="number">2.78</span></span><br><span class="line">n1 = <span class="number">0.5</span></span><br><span class="line">n2 = <span class="number">-.48</span></span><br><span class="line">n3 = <span class="number">1.5</span></span><br><span class="line"> </span><br><span class="line">scale = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line">Unum = <span class="number">50</span></span><br><span class="line">Vnum = <span class="number">50</span></span><br><span class="line"> </span><br><span class="line">Uinc = math.pi / (Unum/<span class="number">2</span>)</span><br><span class="line">Vinc = (math.pi/<span class="number">2</span>)/(Vnum/<span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#fill verts array</span></span><br><span class="line">theta = -math.pi</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, Unum + <span class="number">1</span>):</span><br><span class="line">    phi = -math.pi/<span class="number">2</span></span><br><span class="line">    r1 = <span class="number">1</span>/(((abs(math.cos(m*theta/<span class="number">4</span>)/a))**n2+(abs(math.sin(m*theta/<span class="number">4</span>)/b))**n3)**n1)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>,Vnum + <span class="number">1</span>):</span><br><span class="line">        r2 = <span class="number">1</span>/(((abs(math.cos(m*phi/<span class="number">4</span>)/a))**n2+(abs(math.sin(m*phi/<span class="number">4</span>)/b))**n3)**n1)</span><br><span class="line">        x = scale * (r1 * math.cos(theta) * r2 * math.cos(phi))</span><br><span class="line">        y = scale * (r1 * math.sin(theta) * r2 * math.cos(phi))</span><br><span class="line">        z = scale * (r2 * math.sin(phi))</span><br><span class="line"> </span><br><span class="line">        vert = (x,y,z) </span><br><span class="line">        verts.append(vert)</span><br><span class="line">        <span class="comment">#increment phi</span></span><br><span class="line">        phi = phi + Vinc</span><br><span class="line">    <span class="comment">#increment theta</span></span><br><span class="line">    theta = theta + Uinc</span><br><span class="line"> </span><br><span class="line"><span class="comment">#fill faces array</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">0</span>, (Vnum + <span class="number">1</span>) *(Unum)):</span><br><span class="line">    <span class="keyword">if</span> count &lt; Vnum:</span><br><span class="line">        A = i</span><br><span class="line">        B = i+<span class="number">1</span></span><br><span class="line">        C = (i+(Vnum+<span class="number">1</span>))+<span class="number">1</span></span><br><span class="line">        D = (i+(Vnum+<span class="number">1</span>))</span><br><span class="line"> </span><br><span class="line">        face = (A,B,C,D)</span><br><span class="line">        faces.append(face)</span><br><span class="line"> </span><br><span class="line">        count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#create mesh and object</span></span><br><span class="line">mymesh = bpy.data.meshes.new(<span class="string">"supershape"</span>)</span><br><span class="line">myobject = bpy.data.objects.new(<span class="string">"supershape"</span>,mymesh)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#set mesh location</span></span><br><span class="line">myobject.location = bpy.context.scene.cursor.location</span><br><span class="line">bpy.context.collection.objects.link(myobject)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#create mesh from python data</span></span><br><span class="line">mymesh.from_pydata(verts,edges,faces)</span><br><span class="line">mymesh.update(calc_edges=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#set the object to edit mode</span></span><br><span class="line"><span class="comment">#bpy.context.scene.objects.active = myobject</span></span><br><span class="line"><span class="comment">#obj = bpy.context.window.scene.objects[0]</span></span><br><span class="line">bpy.context.view_layer.objects.active = myobject</span><br><span class="line">bpy.ops.object.mode_set(mode=<span class="string">'EDIT'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># remove duplicate vertices</span></span><br><span class="line">bpy.ops.mesh.remove_doubles() </span><br><span class="line"> </span><br><span class="line"><span class="comment"># recalculate normals</span></span><br><span class="line">bpy.ops.mesh.normals_make_consistent(inside=<span class="literal">False</span>)</span><br><span class="line">bpy.ops.object.mode_set(mode=<span class="string">'OBJECT'</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># subdivide modifier</span></span><br><span class="line">myobject.modifiers.new(<span class="string">"subd"</span>, type=<span class="string">'SUBSURF'</span>)</span><br><span class="line">myobject.modifiers[<span class="string">'subd'</span>].levels = <span class="number">3</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># show mesh as smooth</span></span><br><span class="line">mypolys = mymesh.polygons</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> mypolys:</span><br><span class="line">    p.use_smooth = <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用&lt;code&gt;python&lt;/code&gt;来进行blender建模。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="blender" scheme="https://github.com/donghufeng/tags/blender/"/>
    
  </entry>
  
  <entry>
    <title>新机配置流程</title>
    <link href="https://github.com/donghufeng/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
    <id>https://github.com/donghufeng/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</id>
    <published>2020-03-29T16:05:57.000Z</published>
    <updated>2020-03-31T10:52:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>新机器配置过程。<br><a id="more"></a></p><h1 id="装机流程"><a href="#装机流程" class="headerlink" title="装机流程"></a>装机流程</h1><ul><li>安装pip</li></ul><p><code>sudo apt install python3-pip</code></p><ul><li>生存ssh密钥</li></ul><p><code>ssh-keygen -t rsa -C &quot;your@email&quot;</code></p><ul><li><p>下载vscode</p></li><li><p>下载setting-sync插件</p></li></ul><p>Gist id: e7084f25b33de90bddd1a98977971d41</p><p>token: xxxx</p><ul><li>免费ssr</li></ul><p>ssr://NDUuMTM2LjI0NC4yMDU6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6Wkdab1oyWnE</p><p>ssr://NDUuMTI5LjMuMTMxOjQ0MzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jdHI6dGxzMS4yX3RpY2tldF9hdXRoOmFtaGtaMmhrWm1j</p><p>ssr://NDUuMTI5LjMuNTc6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6WjJabmFHZG1jMlJvYVd0cWVYVnlaUQ</p><p>ssr下载地址：</p><ol><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf</a></p></li><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc</a></p></li></ol><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><ol><li>安装ss客户端</li></ol><p><code>pip install git+https://github.com/shadowsocks/shadowsocks.git@master</code></p><ol><li>ss配置文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"XXXXXXX"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: XXXXXX,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"XXXXXX"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"aes-256-gcm"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地地址为<code>127.0.0.1</code>，端口为<code>1080</code>。</p><ol><li>启动ss</li></ol><p><code>sslocal -c /xxx/xxx/sslocal-config.json &amp;</code></p><h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><p>ss是socks5协议，需要做http转发，供整个系统使用</p><ol><li>安装privoxy</li></ol><p><code>sudo apt install privoxy</code></p><ol><li>配置privoxy</li></ol><p>在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen-address 127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>表示privoxy对本机的代理端口为<code>8118</code>。</p><p>如果需要全局代理，则在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的http请求都使用本机的1080端口的socks5协议来转发。</p><p>如果需要局部代理，则注释掉上面全局代理的那行，加上：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 .google.com 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的<code>.google.com</code>的http请求都从本机的1080端口转发，而其他的网站则不做代理。</p><p>同时也可以通过文件的方式制定更多的网站代理。复制<code>gfwlist.action</code>到<code>/etc/privoxy</code>目录下，并在该目录下的设置文件<code>config</code>中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionsfile gfwlist.action</span><br></pre></td></tr></table></figure><p>表明该文件中的网站都做代理。</p><ol><li>启动privoxy</li></ol><p><code>sudo service privoxy start</code></p><p>该命令是开机自动启动，因此下次开机不需要运行。</p><ol><li>设置本机代理</li></ol><p>在本机的网络代理设置中选择手动配置代理服务器，将本机的http请求都通过privoxy来代理。对所有协议都选择地址为<code>127.0.0.1</code>端口为<code>8118</code>。</p><ol><li>终端也能利用ss</li></ol><p>对终端的网络也设置代理，在全局变量中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="variable">$proxy</span></span><br></pre></td></tr></table></figure><p>可在<code>～/.bashrc</code>或者<code>/etc/profile</code>中添加上述指令。</p><p>梳理一下流程，通过设置本机代理，将本机的所有<code>http</code>请求都利用<code>privoxy</code>来进行转发。<code>privoxy</code>则根据规则选择性地将http请求转为shadowsocks的socks5协议向目标网站获得数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新机器配置过程。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://github.com/donghufeng/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>python - 类</title>
    <link href="https://github.com/donghufeng/2020/03/21/python-%E7%B1%BB/"/>
    <id>https://github.com/donghufeng/2020/03/21/python-%E7%B1%BB/</id>
    <published>2020-03-21T07:32:00.000Z</published>
    <updated>2020-03-30T13:32:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>介绍python面向对象编程时的一些方法。<br><a id="more"></a></p><h2 id="抽象方法、类方法和静态方法"><a href="#抽象方法、类方法和静态方法" class="headerlink" title="抽象方法、类方法和静态方法"></a>抽象方法、类方法和静态方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""person</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setdoc</span><span class="params">(cls,doc)</span>:</span></span><br><span class="line">        cls.__doc__=doc</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"hi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">woman</span><span class="params">(person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    woman</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        person.__init__(self)</span><br><span class="line">        self.sex=<span class="string">'woman'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line">alice=woman()</span><br><span class="line"></span><br><span class="line"><span class="comment"># staticmethod</span></span><br><span class="line">alice.sayhi() <span class="comment">#hi</span></span><br><span class="line">woman.sayhi() <span class="comment">#hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classmethod</span></span><br><span class="line">print(alice.__doc__) <span class="comment">#woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#woman</span></span><br><span class="line">alice.setdoc(<span class="string">"set by alice"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">woman.setdoc(<span class="string">"set by woman"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by woman</span></span><br><span class="line"><span class="comment"># %%</span></span><br></pre></td></tr></table></figure><p><code>@abstractmethod</code>:</p><p>必须被子类重新实现，否者在实例化时就会报错</p><p><code>@classmethod</code>:</p><p>类方法可通过实例调用，也可通过类直接调用，改变的是类本身的参数，类方法的第一个关键字是cls</p><p><code>@staticmethod</code></p><p>静态方法，可通过类本身或者实例来调用，不会改变类或者实例本身的任何东西，但是该方法隶属于该类，这么写是为了方便代码组织。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;介绍python面向对象编程时的一些方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/donghufeng/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="抽象方法" scheme="https://github.com/donghufeng/tags/%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    
      <category term="类方法" scheme="https://github.com/donghufeng/tags/%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
    
      <category term="静态方法" scheme="https://github.com/donghufeng/tags/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Quantum Chemistry - Basic</title>
    <link href="https://github.com/donghufeng/2020/03/20/Quantum-Chemistry-Basic/"/>
    <id>https://github.com/donghufeng/2020/03/20/Quantum-Chemistry-Basic/</id>
    <published>2020-03-20T05:47:31.000Z</published>
    <updated>2020-03-20T07:47:53.690Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Modern Quantum Chemistry</em>.<br>基本知识。</p><a id="more"></a><h2 id="原子单位"><a href="#原子单位" class="headerlink" title="原子单位"></a>原子单位</h2><p>原子单位是为了进行无量纲处理。氢原子的电子波动方程可写为：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e}\nabla^2-\frac{e^2}{4\pi\varepsilon_0r}\right]\phi=E\phi</script><p>对长度进行无量纲化，取$r=\lambda r’$，代入上式可得：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e \lambda^2}\nabla'^2-\frac{e^2}{4\pi\varepsilon_0r'\lambda}\right]\phi=E\phi</script><p>令:</p><script type="math/tex; mode=display">\frac{\hbar^2}{m_e \lambda^2}=\frac{e^2}{4 \pi \varepsilon_0 \lambda}=E_a</script><p>称$E_a$为一个<em>Hartree</em>，约为$27.211\text{eV}$，由上式可得：</p><script type="math/tex; mode=display">\lambda=\frac{4 \pi\varepsilon_0 \hbar^2}{m_e e^2}=a_0</script><p>称$a_0$为玻尔半径，约为0.52918埃。经过单位转化过后，薛定谔方程变为：</p><script type="math/tex; mode=display">\left(-\frac{1}{2} \nabla'^2-\frac{1}{r'}\right)\phi'=E'\phi'</script><p>因此在原子单位里，能力的单位为一个Hartree $E_a$，长度的单位为一个波尔半径$a_0$。</p><h2 id="多体相互作用哈密顿量"><a href="#多体相互作用哈密顿量" class="headerlink" title="多体相互作用哈密顿量"></a>多体相互作用哈密顿量</h2><p>对于$M$个原子和$N$个电子的系统，其哈密顿量在原子单位下可写为：</p><script type="math/tex; mode=display">\begin{aligned}H&=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{A=1}^{M}\frac{1}{2M_A}\nabla _{A}^{2}-\sum_{i=1}^{M}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}\\&+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}\end{aligned}</script><h2 id="电子哈密顿量"><a href="#电子哈密顿量" class="headerlink" title="电子哈密顿量"></a>电子哈密顿量</h2><p>由于原子比电子重很多，因此可以近似认为原子是不动的，只有电子在原子所形成的场中运动，那么原子的动能将为被忽略，而原子之间的相互作用将为常数，因此哈密顿量可以简化为：</p><script type="math/tex; mode=display">H_\text{elec}=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{i=1}^{N}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}</script><p>并称其为电子哈密顿量。设其本征值为$E_\text{elec}$，那么系统总能量是电子能量和原子排斥能之和，则为：</p><script type="math/tex; mode=display">E_ \text{tot}=E_ \text{elec}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}</script><h2 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h2><p>电子具有$1/2$自旋，因此电子的坐标是由位置坐标和自旋方向构成：</p><script type="math/tex; mode=display">x=\{r,w\}</script><p>泡利不相容原理说，电子波函数中，交换两个电子不能同时处于同意空间位置，因此有：</p><script type="math/tex; mode=display">\Phi \left(x_1,\cdots,x_i,\cdots,x_j,\cdots,x_n\right)=-\Phi \left(x_1,\cdots,x_j,\cdots,x_i,\cdots,x_n\right)</script><h2 id="单电子波函数"><a href="#单电子波函数" class="headerlink" title="单电子波函数"></a>单电子波函数</h2><p>单电子波函数由空间波函数和自旋波函数构成：</p><script type="math/tex; mode=display">\chi(x)=\psi(r) \left|+\right> \text{or } \psi(r) \left|-\right></script><p>对于多电子哈密顿量来说，如果忽略电子之间的排斥力，则多电子波函数是单电子波函数的乘积构成，称为<strong>Hartree Product</strong>。但是该波函数不满足泡利反对称性，因此需要通过如下方法构造。</p><h2 id="Slater-Determinats"><a href="#Slater-Determinats" class="headerlink" title="Slater Determinats"></a>Slater Determinats</h2><p>联想到在矩阵求秩时，任意交换两行则秩会反号，因此可通过求单电子波函数构成的矩阵的秩的方法来求多电子波函数的满足反对称性的波函数。</p><script type="math/tex; mode=display">\Psi(x_1,\cdots,x_N)=\frac{1}{\sqrt{N!}} \begin{vmatrix}\chi_i(x_1)&\chi_j(x_1)&\cdots&\chi_k(x_1)\\\chi_i(x_2)&\chi_j(x_2)&\cdots&\chi_k(x_2)\\\vdots&\vdots&&\vdots\\\chi_i(x_N)&\chi_j(x_N)&\cdots&\chi_k(x_N)\end{vmatrix}</script><p>并简写为：</p><script type="math/tex; mode=display">\Psi= \left|\chi_i\chi_j\cdots\chi_k\right></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Modern Quantum Chemistry&lt;/em&gt;.&lt;br&gt;基本知识。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Quantum Chemistry" scheme="https://github.com/donghufeng/categories/Quantum-Chemistry/"/>
    
    
      <category term="计算化学" scheme="https://github.com/donghufeng/tags/%E8%AE%A1%E7%AE%97%E5%8C%96%E5%AD%A6/"/>
    
      <category term="原子单位" scheme="https://github.com/donghufeng/tags/%E5%8E%9F%E5%AD%90%E5%8D%95%E4%BD%8D/"/>
    
      <category term="Hartree" scheme="https://github.com/donghufeng/tags/Hartree/"/>
    
      <category term="波尔半径" scheme="https://github.com/donghufeng/tags/%E6%B3%A2%E5%B0%94%E5%8D%8A%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 阶查找</title>
    <link href="https://github.com/donghufeng/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
    <id>https://github.com/donghufeng/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/</id>
    <published>2020-03-19T04:05:18.000Z</published>
    <updated>2020-03-19T04:48:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子阶查找算法。<br><a id="more"></a></p><h2 id="阶查找算法"><a href="#阶查找算法" class="headerlink" title="阶查找算法"></a>阶查找算法</h2><p>对于两个正整数 $x,N,x&lt;N $，该算法能找到最小的整数$r$，且满足$x^r=1(\text{mod } N)$。利用相位估计算法可以近似求解改问题。</p><p>假设有酉算符满足：</p><script type="math/tex; mode=display">U \left|y\right>=\left|xy(\text{mod }N)\right></script><p>$U$的本征态为$\left|u_s\right&gt;$，且有：</p><script type="math/tex; mode=display">\left|u_s\right>=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right></script><p>下面证明改态确实是$U$的本征态。</p><script type="math/tex; mode=display">\begin{aligned}U \left|u_s\right>&=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\\&=e^{2\pi is/r}\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is (k+1)}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\end{aligned}</script><p>又因为：</p><script type="math/tex; mode=display">\exp \left[\frac{-2\pi is r}{r}\right]\left|x^r(\text{mod }N)\right>=\left|1(\text{mod }N)\right>=\exp \left[\frac{-2\pi is 0}{r}\right]\left|x^0(\text{mod }N)\right></script><p>所以：</p><script type="math/tex; mode=display">U \left|u_s\right>=\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right></script><p>因此，可以利用相位估计算法，得到$s/r$，并计算得到阶数$r$。然而，在相位估计算法中，第二个寄存器所需要构造的态$\left|u_s\right&gt;$中已经包含$r$，这不合理。注意到：</p><script type="math/tex; mode=display">\begin{aligned}\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_s\right>&=\frac{1}{r}\sum_{k=0}^{r-1}\sum_{s=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{k0}\left|x^k(\text{mod }N)\right>\\&=\left|1\right>\end{aligned}</script><p>可以将第二个寄存器的处态制备为全$\left|1\right&gt;$，此时：</p><script type="math/tex; mode=display">\begin{aligned}U \left|1\right>&=\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right>\\&=\frac{1}{r}\sum_{s=0}^{r-1}\sum_{k=0}^{r-1}\exp \left[\frac{2\pi is(1-k)}{r}\right] \left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{1k} \left|x^k(\text{mod }N)\right>\\&=\left|x\right>\end{aligned}</script><blockquote><p>此处存疑，$\left|1\right&gt;$不是$U$的本征态！相位估计该怎么做？？？</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子阶查找算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="阶查找" scheme="https://github.com/donghufeng/tags/%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 相位估计</title>
    <link href="https://github.com/donghufeng/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/"/>
    <id>https://github.com/donghufeng/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/</id>
    <published>2020-03-18T09:37:48.000Z</published>
    <updated>2020-03-19T00:37:33.739Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子相位估计算法。<br><a id="more"></a></p><h2 id="相位估计问题"><a href="#相位估计问题" class="headerlink" title="相位估计问题"></a>相位估计问题</h2><p>假设有酉算符$U$，其本征态为$\left|u\right&gt;$，对应的本征值为$e^{2\pi i\varphi}$，相位估计算法可以对$\varphi$进行指定精度的估计，注意，这里$0\le\varphi\le1$。改算法第一个步骤的线路图如下：</p><p><img src="/img/pe.png" alt="相位估计"></p><p>图中上半部分的寄存器由$t$个比特构成，下半部分的寄存器存储的是本征态$\left|u\right&gt;$。首先对第一个寄存器作用$H^{\otimes t}$，然后依次选择第$j$个比特对第二个寄存器做受控$U^{2^j-1}$操作。因此第一个寄存器的态为：</p><script type="math/tex; mode=display">H^{\otimes t}\left|0\right>^{\otimes t}=\frac{1}{\sqrt{2^t}}\sum_j \left|j\right>=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1}\left|j_1\cdots j_{t}\right></script><p>作用第一个控制门：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_1\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t-1}=0}^{1} \left|j_1\cdots j_{t-1}\right>\left(\left|0\right>+e^{2\pi i \varphi(2^0 )}\left|1\right>\right)\\&=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第二个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_2\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{t-1}2^1+j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第$t$个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_{t}\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{1}2^{t-1}+j_t 2^0)}\left|j_1\cdots j_{t}\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi j}\left|j\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi\cdot 2^t j/2^t}\left|j\right>\end{aligned}</script><p>可见第一个寄存器的末态是对$\left|2^t\varphi\right&gt;$进行傅里叶变换得到的，因此，如果$\varphi$可以写为$\varphi=0.\varphi_1\cdots\varphi_t$时，对其作用傅里叶逆变换将得到$\varphi$的精确值。如果不能精确写出此形式，则可以在$2^{-n}$的精确度下近似得到$\varphi$，此时所需的比特数为：</p><script type="math/tex; mode=display">t=n+\left\lceil\log \left(2+\frac{1}{2\epsilon}\right)\right\rceil.</script><p>整体的线路图为：</p><p><img src="/img/pe2.png" alt="相位估计2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子相位估计算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="相位估计" scheme="https://github.com/donghufeng/tags/%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>拍平一个矩阵</title>
    <link href="https://github.com/donghufeng/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/"/>
    <id>https://github.com/donghufeng/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/</id>
    <published>2020-03-16T08:17:04.000Z</published>
    <updated>2020-03-16T14:40:46.656Z</updated>
    
    <content type="html"><![CDATA[<p>如何拍平一个矩阵？<br><a id="more"></a></p><ul><li><code>x.flatten</code></li><li><code>x.revel</code></li><li><code>x.reshape(-1)</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何拍平一个矩阵？&lt;br&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://github.com/donghufeng/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/donghufeng/tags/python/"/>
    
      <category term="技巧" scheme="https://github.com/donghufeng/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 各种分解</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/</id>
    <published>2020-03-16T05:28:14.000Z</published>
    <updated>2020-03-16T15:09:59.056Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍矩阵的各种分解。<br><a id="more"></a></p><h2 id="极分解-Polar-decomposition"><a href="#极分解-Polar-decomposition" class="headerlink" title="极分解(Polar decomposition)"></a>极分解(Polar decomposition)</h2><p>对于$V$空间中的任意算符$A$，能将其按照如下形式分解</p><script type="math/tex; mode=display">A=UJ=KU</script><p>其中，$U$为酉矩阵，且$J$为半正定矩阵，$J=\sqrt{A^\dagger A}$，$K=\sqrt{AA^\dagger}$，如果$A$可逆，则$U$唯一。<br><strong>证明：</strong></p><ol><li>取$V$空间的一组基矢$\left|i\right&gt;$和任意态$\left|v\right&gt;$，则：<script type="math/tex; mode=display">\left<v\right|A^\dagger A \left|v\right>=\sum_i\left|a_i\right|^2\ge 0</script>因此$A^\dagger A$是对称半正定矩阵，$\sqrt{A^\dagger A}$也是对称半正定矩阵。</li><li>根据谱定理，对于半正定矩阵有：<br><script type="math/tex">J=\sqrt{A^\dagger A}=\sum_i \lambda_i \left|i\right>\left<i\right|(\lambda_i\ge0)</script>。</li><li>定义$\left|\psi_i\right&gt;=A \left|i\right&gt;$，因此有：<br><script type="math/tex">\left<\psi_i\mid \psi_i\right>=\left<i\right|A^\dagger A\left|i\right>=\lambda_i^2</script>。</li><li>对于$\lambda_i\neq 0$的态，定义$\left|e_i\right&gt;=\left|\psi_i\right&gt;/\lambda_i$，因此$\left|e_i\right&gt;$是彼此正交的单位矢量。</li><li>利用Schmidt正交化方法对$\left|e_i\right&gt;$进行扩充，使得其为$V$中的基矢，并仍然记为$\left|e_i\right&gt;$。</li><li>定义酉算符$U=\sum_i \left|e_i\right&gt;\left&lt;i\right|$。</li><li>对于$\lambda_i\neq 0$的那些态，有<br><script type="math/tex">UJ \left|i\right>=\lambda_i U \left|i\right>=\lambda_i \left|e_i\right>=\left|\psi_i\right>=A \left|i\right></script>。</li><li>对于$\lambda_i =0$的态来说，有<script type="math/tex; mode=display">UJ \left|i\right>=0=\left|\psi_i\right>=A \left|i\right></script></li></ol><p>综上，$A=UJ$。此时，$A=UJ=UJU^\dagger U=KU$，且$K=UJU^\dagger=K^\dagger$，此时</p><script type="math/tex; mode=display">AA^\dagger=KUU^\dagger K^\dagger=K^2</script><p>所以$K=\sqrt{AA^\dagger}$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>对于任意方矩阵，总可以按照如下分解，</p><script type="math/tex; mode=display">A=UDV</script><p>其中，$U$和$V$是酉矩阵，$D$是对角矩阵，称为$A$的奇异值。<br><strong>证明：</strong></p><ol><li>根据极分解，$A=SJ$，其中$S$为酉矩阵，$J$为半正定矩阵。</li><li>根据谱分解定理，$J=TDT^\dagger$，其中$T$为酉矩阵，$D$为对角矩阵。</li><li>由上：<script type="math/tex; mode=display">A=SJ=STDT^\dagger</script></li></ol><p>因此有$U=ST$，$V=T^\dagger$。</p><h2 id="Schmidt分解"><a href="#Schmidt分解" class="headerlink" title="Schmidt分解"></a>Schmidt分解</h2><p>复合系统$AB$中的纯态$ \left|\psi\right&gt; $总能按如下分解：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_i \lambda_i \left|i_A\right> \left|i_B\right></script><p>其中$ \left|i_A\right&gt; $和$ \left|i_B\right&gt; $分别为两个子系统的正交归一基矢，且$\lambda_i$是正实数，满足归一化条件$\sum_i\lambda_i^2=1$。</p><p><strong>证明：</strong></p><p>这里假设两个子系统的空间维度一样，并且取两个子系统的任意正交归一基矢为$ \left|j\right&gt; $和$ \left|k\right&gt; $，则复合空间$AB$中的纯态$ \left|\psi\right&gt; $可按照子空间的基矢展开：</p><script type="math/tex; mode=display">\left|\psi\right> =\sum_{jk}a_{jk} \left|j\right> \left|k\right></script><p>系数矩阵$a$为方阵，可进行奇异值分解$a=udv$，因此：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_{ijk} u_{ji}d_{ii}v_{ik}\left|j\right> \left|k\right></script><p>令$ \left|i_A\right&gt;=\sum_ju_{ji} \left|j\right&gt;, \left|i_B\right&gt;=\sum_k v_{ik} \left|k\right&gt;, \lambda_i=d_{ii} $，即可得到满足条件的分解。此时有</p><script type="math/tex; mode=display">\begin{aligned}    \rho^A&=\text{tr}_B(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_A\right>\left<i_A\right|\\    \rho^B&=\text{tr}_A(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_B\right>\left<i_B\right|\end{aligned}</script><p>易知，$ \left|i_X\right&gt; $为纯态$ \left|\psi\right&gt; $在子系统$X$中的约化密度矩阵$\rho^X$的本征态，$\lambda_i^2$为两个子系统约化密度矩阵的共同本征值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;介绍矩阵的各种分解。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="极分解" scheme="https://github.com/donghufeng/tags/%E6%9E%81%E5%88%86%E8%A7%A3/"/>
    
      <category term="奇异值分解" scheme="https://github.com/donghufeng/tags/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    
      <category term="Schmidt分解" scheme="https://github.com/donghufeng/tags/Schmidt%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 密度算符与迹</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/</id>
    <published>2020-03-16T05:24:20.000Z</published>
    <updated>2020-03-16T05:27:09.083Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>记录零碎知识点。<br><a id="more"></a></p><h2 id="密度矩阵"><a href="#密度矩阵" class="headerlink" title="密度矩阵"></a>密度矩阵</h2><p>混态不能用一个态标识出来，系统中出现态$\left|\psi_i\right&gt;$的概率为$p_i$，密度矩阵可写为：</p><script type="math/tex; mode=display">\rho=\sum_i^np_i \left|\psi_i\right>\left<\psi_i\right|</script><p>这里当$n=1$是为纯态密度矩阵。可观察量$A$在混态中的期望值为：</p><script type="math/tex; mode=display">E(A)=\sum_i^n p_i \left<\psi_i\right|A\left|\psi_i\right>=\text{tr}(\rho A)</script><p>纯态也有相同结果 。</p><p>混态的$\text{tr}(\rho^2)&lt;1$：</p><script type="math/tex; mode=display">\text{tr}(\rho^2)=\sum_{i,j}p_j^2 \left<i\mid \psi_j\right> \left<\psi_j\mid i\right>\le\sum_i p_i^2<\sum_i p_i=1</script><p>对于纯态来说：</p><script type="math/tex; mode=display">\left|\psi\right>=\cos\frac{\theta}{2} \left|0\right>+e^{i\varphi}\sin{\frac{\theta}{2}} \left|1\right></script><p>其密度矩阵为：</p><script type="math/tex; mode=display">\begin{aligned}\rho&= \left|\psi\right>\left<\psi\right|\\&= \begin{pmatrix}\cos^2\frac{\theta}{2}&\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{-i\varphi}\\\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{i\varphi}&\sin^2\frac{\theta}{2}\end{pmatrix}\\&= \frac{1}{2}\begin{pmatrix}1+\cos\theta&\sin\theta e^{-i\varphi}\\\sin\theta e^{i\varphi}&1-\cos\theta\end{pmatrix}\\&=\frac{I+\vec{r}\cdot \vec{\sigma}}{2}\end{aligned}</script><p>对于混态来说，有$\rho=\sum_i p_i \rho_i$，因此，也有上述的形式。</p><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><p>对于任意算符$A$，和一组正交基矢$\left|i\right&gt;$,迹的定义为：</p><script type="math/tex; mode=display">\text{tr}(A)=\sum_i \left<i\right|A\left|i\right>=\sum_i A_{ii}</script><p>取任意态$\left|\psi\right&gt;$，则有$\text{tr}(A \left|\psi\right&gt;\left&lt;\psi\right|)=\left&lt;\psi\right|A\left|\psi\right&gt;$，证明如下：</p><script type="math/tex; mode=display">\text{tr}(A \left|\psi\right>\left<\psi\right|)=\sum_i \left<i\right|A\left|\psi\right> \left<\psi\mid i\right>=\sum_i  \left<\psi\mid i\right>\left<i\right|A\left|\psi\right>=\left<\psi\right|A\left|\psi\right></script><h2 id="约化密度矩阵和偏迹"><a href="#约化密度矩阵和偏迹" class="headerlink" title="约化密度矩阵和偏迹"></a>约化密度矩阵和偏迹</h2><script type="math/tex; mode=display">\rho^A=\text{tr}_B(\rho^{AB})</script><p>e.g.:</p><script type="math/tex; mode=display">\text{tr}_B(\left|a_1\right>\left<a_2\right|\otimes \left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right|\text{tr}(\left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right| \left<b_2\mid b_1\right></script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;记录零碎知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="密度矩阵" scheme="https://github.com/donghufeng/tags/%E5%AF%86%E5%BA%A6%E7%9F%A9%E9%98%B5/"/>
    
      <category term="迹" scheme="https://github.com/donghufeng/tags/%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - Cauchy-Schwarz不等式</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/</id>
    <published>2020-03-16T05:19:12.000Z</published>
    <updated>2020-03-16T05:21:52.176Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍Cauchy-Schwarz不等式。<br><a id="more"></a></p><h2 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h2><p>希尔伯特空间中的两个态矢量$\left|v\right&gt;$和$\left|w\right&gt;$，则有：</p><script type="math/tex; mode=display">\left| \left<v\mid w\right>\right|^2\le \left<v\mid v\right> \left<w\mid w\right></script><p><strong>证明：</strong><br>在希尔伯特空间中选择一组基矢$\left|i\right&gt;$，并使得该组基矢的第一个为</p><script type="math/tex; mode=display">\left|w\right>/\sqrt{\left<w\mid w\right>}</script><p>因此：</p><script type="math/tex; mode=display">\begin{aligned}\left<v\mid v\right>\left<w\mid w\right>&=\sum_i \left<v\mid i\right>\left<i\mid v\right>\left<w\mid w\right>\\&\ge\frac{\left<v\mid w\right>\left<w\mid v\right>}{\left<w\mid w\right>}\left<w\mid w\right>\\&=\left|\left<v\mid w\right>\right|^2\end{aligned}</script><p>取$\ge$是因为求和中只取第一个基矢，而忽略掉有剩余基矢得到的数（为正数）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;介绍Cauchy-Schwarz不等式。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="Cauchy-Schwarz不等式" scheme="https://github.com/donghufeng/tags/Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Hexo注意事项</title>
    <link href="https://github.com/donghufeng/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>https://github.com/donghufeng/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-03-16T04:42:52.000Z</published>
    <updated>2020-03-16T05:18:09.315Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo使用过程中的注意事项。<br><a id="more"></a></p><ul><li>大括号{}问题。</li></ul><p>在公式中，如果要显示”{}”，需要加两个”//“，如$\{\}$。</p><ul><li>量子态问题</li></ul><p>如果一段话中有两个态矢量，且里面的字母有大括号包围的下脚标，需要将”_<em>“改为”\_</em>“，如：</p><p>$\left|a_{0}\right&gt;$b$\left|c_{1}\right&gt;.$</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Hexo使用过程中的注意事项。&lt;br&gt;
    
    </summary>
    
    
    
      <category term="Hexo" scheme="https://github.com/donghufeng/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 量子傅里叶变换</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</id>
    <published>2020-03-16T04:31:18.000Z</published>
    <updated>2020-03-19T02:58:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子傅里叶变换算法。<br><a id="more"></a></p><!-- slide --><h2 id="经典离散傅里叶算法"><a href="#经典离散傅里叶算法" class="headerlink" title="经典离散傅里叶算法"></a>经典离散傅里叶算法</h2><p>对于数据点集合$A=\{A_i,i=0,N-1\}$，其离散傅里叶变化为</p><script type="math/tex; mode=display">B_j=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}{e^{2\pi i jk/N}A_k}</script><!-- slide --><h2 id="量子离散傅里叶算法"><a href="#量子离散傅里叶算法" class="headerlink" title="量子离散傅里叶算法"></a>量子离散傅里叶算法</h2><p>n比特的态可以表示成$\left|j_1j_2…j_n\right&gt;$，可将态看着二进制数，从而也可将态写成十进制数表示为$\left|j\right&gt;$，其中</p><script type="math/tex; mode=display">j=[j_1\cdots j_n]=j_1 * 2^{n-1}+j_i*2^{n-i}+j_n</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">3</span></span><br><span class="line">s=<span class="string">'111'</span></span><br><span class="line">k=int(s,<span class="number">2</span>) <span class="comment"># 参数2用来表示从二进制转化为十进制</span></span><br><span class="line">s==bin(k)[<span class="number">2</span>:].zfill(n) <span class="comment">#bin函数用来转化为二进制，zfill函数用来补零</span></span><br></pre></td></tr></table></figure><!-- slide --><p>对于二进制的分数表示$0.j_1j_2\cdots j_n$，其表示为十进制为</p><script type="math/tex; mode=display">[0.j_1j_2\cdots j_n]=j_1*2^{-1}+\cdots+j_n*2^{-n}=\sum_{k=1}^{n}j_k*2^{-k}.</script><p>我们有$[0.j_1\cdots j_n]=[j_1\cdots j_n]/2^n.$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">3</span></span><br><span class="line">s=<span class="string">'0.011'</span></span><br><span class="line">k=int(s[<span class="number">2</span>:],<span class="number">2</span>)/<span class="number">2</span>**n</span><br><span class="line">s==<span class="string">'0.'</span>+bin(int(k*<span class="number">2</span>**n))[<span class="number">2</span>:].zfill(n)</span><br></pre></td></tr></table></figure><!-- slide --><p>对于态$\left|j\right&gt;$，其傅里叶变换定义为</p><script type="math/tex; mode=display">\left|j\right>\rightarrow\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}e^{2\pi i jk/N}\left|k\right>,</script><p>其中$N=2^n$，设$\omega_n=e^{\frac{2\pi i}{2^n}}$其矩阵表示为，</p><script type="math/tex; mode=display">\begin{pmatrix}\left|0\right>\\\vdots\\\left|j\right>\\\vdots\\\left|N-1\right>\end{pmatrix}=\frac{1}{\sqrt{N}}\begin{pmatrix}1&\cdots&1&\cdots&1\\\vdots&\cdots&\vdots&\cdots&\vdots\\1&\cdots&\omega_n^{j k}&\cdots&\omega_n^{j (N-1)}\\\vdots&\cdots&\vdots&\cdots&\vdots\\1&\cdots&\omega_n^{(N-1)k}&\cdots&\omega_n^{(N-1)^2}\\\end{pmatrix}\begin{pmatrix}\left|0\right>\\\vdots\\\left|k\right>\\\vdots\\\left|N-1\right>\end{pmatrix}</script><!-- slide --><p>根据定义</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{N}\left|j\right>&\rightarrow\sum_{k=0}^{N-1}e^{2\pi ijk/N}\left|k\right>\\&=\sum_{k=0}^{N-1}e^{2\pi i k[0.j_1\cdots j_{n}]}\left|k\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}e^{2\pi i [0.j_1\cdots j_{n}]\sum_{l=1}^{n}2^{l-1}k_{n-l}}\left|k_0\cdots k_{n-1}\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}\prod_{l=1}^{n} e^{2\pi i k_{n-l}[j_1\cdots j_{l-1}.j_{l}\cdots j_n]}\left|k_0\cdots k_{n-1}\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}\prod_{l=1}^{n} e^{2\pi i k_{n-l}[0.j_{l}\cdots j_n]}\left|k_0\cdots k_{n-1}\right>\\&=(\left|0\right>+e^{2\pi i [0.j_n]}\left|1\right>)\otimes \sum_{(k_1,\cdots,k_{n-1})\in \{0,1\}^{(n-1)}}\prod_{l=1}^{n-1} e^{2\pi i k_{n-l}[0.j_{l}\cdots j_n]}\left|k_1\cdots k_{n-1}\right>\\&=\otimes_{l=1}^{n}\left(\left|0\right>+e^{2\pi i[0.j_l\cdots j_n]}\left|1\right>\right)\end{aligned}</script><!-- slide --><p>第四个等式到第五个等式用到事实</p><script type="math/tex; mode=display">e^{2\pi i k_{n-1}[j_1\cdots j_{l-1}.j_l\cdots j_n]}=e^{2\pi i k_{n-1}[j_1\cdots j_{l-1}]}e^{2\pi i k_{n-1}[0.j_{l}\cdots j_{n}]}=1\cdot e^{2\pi i k_{n-1}[0.j_l\cdots j_n]}</script><!-- slide --><h2 id="门实现"><a href="#门实现" class="headerlink" title="门实现"></a>门实现</h2><p>对于目标态</p><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_n]}\left|1\right>)\\&=H\left|j_n\right>\end{aligned}</script><p>对于目标态</p><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_{n-1}j_n]}\left|1\right>)\\&=\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_{n-1}]}e^{2\pi i [0.0j_n]}\left|1\right>)\end{aligned}</script><!-- slide --><p>可先对$\left|j_{n-1}\right&gt;$做哈德马德变换，再做用$\left|j_{n}\right&gt;$控制$\left|j_{n-1}\right&gt;$的相位门$R_2$，其中</p><script type="math/tex; mode=display">R_m=\begin{pmatrix}1&0\\0&e^{2\pi i /(2^m)}\end{pmatrix}</script><p>具体实现如下图，最后再做sweep门交换一下态即可。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Q_fourier_nqubits.png/1280px-Q_fourier_nqubits.png?1557480175741" alt="quantum fourier"></p><!-- slide --><p>量子傅里叶算法所需门的复杂度为$\Theta(n^2)$，而最快的经典傅里叶算法时离散傅里叶算法，复杂度为$\Theta(n2^n)$。</p><!-- slide --><blockquote><p>证明量子傅里叶变换是酉变换。</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\text{FT}^\dagger\text{FT}\left|j\right>&=\text{FT}^\dagger \left[\frac{1}{\sqrt{N}}\sum_k e^{2\pi ijk/N} \left|k\right>\right]\\&=\frac{1}{N}\sum_k\sum_m e^{2\pi i(j-m)k/N} \left|m\right>\\&=\frac{1}{N}\sum_m N\delta_{jm} \left|m\right>\\&=\left|j\right>\end{aligned}</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子傅里叶变换算法。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子傅里叶变换" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 量子并行性</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%B9%B6%E8%A1%8C%E6%80%A7/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%B9%B6%E8%A1%8C%E6%80%A7/</id>
    <published>2020-03-16T04:12:11.000Z</published>
    <updated>2020-03-19T00:37:33.739Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍量子并行性的优越以及相关的重要算法。</p><a id="more"></a><h2 id="量子并行性"><a href="#量子并行性" class="headerlink" title="量子并行性"></a>量子并行性</h2><p>假设有函数$f(x):\{0,1\}^n\rightarrow{0,1}$，可以构造门$U_f$使得</p><script type="math/tex; mode=display">U_f \left|x,y\right>=\left|x,y\oplus f(x)\right></script><ul><li>同时得到$f(x)$的值</li></ul><p>取$\left|x,y\right&gt;=\frac{1}{\sqrt{2^n}}\sum_x \left|x\right&gt;\left|0\right&gt;$，作用$U_f$后，得到</p><script type="math/tex; mode=display">U_f \left|x,y\right>=\frac{1}{\sqrt{2^n}}\sum_x \left|x\right>\left|f(x)\right></script><ul><li>Deutsch算法</li></ul><p>上面得到的态在测量时，只能坍缩到某个特定的$\left|f(x)\right&gt;$，因此并不真正意义上的并行。该算法能得到关于$f(x)$的全局信息。<br><img src="/img/Deutsch.png" alt="Deutsch算法"><br>对于以上线路，经过演算可得到：</p><script type="math/tex; mode=display">\left|\psi_3\right>=\pm \left|f(0)\oplus f(1)\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><p>因此第一个比特是$f(x)$的全局信息$f(0)\oplus f(1)$。计算过程用到一个关键点：</p><script type="math/tex; mode=display">U_f \left|x\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}=(-1)^{f(x)}\left|x\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><ul><li>Deutsch-Jozsa算法</li></ul><p>如果Alice手上的$f(x)$确保是常值函数或者平衡函数，Bob如何快速（尽量少次数地交换信息）判断出是什么函数？<br><img src="/img/Deutsch-Jozsa.png" alt="Deutsch-Jozsa算法"><br>根据演化可得到：</p><script type="math/tex; mode=display">\left|\psi_3\right>=\frac{1}{2^n}\sum_z\sum_x(-1)^{f(x)+x\cdot z}\left|z\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><p>注意到，取$\left|z\right&gt;=\left|0\right&gt;^{\otimes n}$时，$\sum_x(-1)^{f(x)}/2^n$对于$f$为常值函数时已经归一化，$\left|z\right&gt;$取不到其他态，因此前$n$个比特只能全为0；当$f$为平衡函数时，$\left|z\right&gt;$中$\left|0\right&gt;^{\otimes n}$项的振幅为0，因此，前$n$个比特必不能全为0。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;介绍量子并行性的优越以及相关的重要算法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子并行性" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E5%B9%B6%E8%A1%8C%E6%80%A7/"/>
    
      <category term="Deutsch算法" scheme="https://github.com/donghufeng/tags/Deutsch%E7%AE%97%E6%B3%95/"/>
    
      <category term="Deutsch-Jozsa算法" scheme="https://github.com/donghufeng/tags/Deutsch-Jozsa%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 量子隐形传态</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E9%9A%90%E5%BD%A2%E4%BC%A0%E6%80%81/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E9%9A%90%E5%BD%A2%E4%BC%A0%E6%80%81/</id>
    <published>2020-03-16T04:05:16.000Z</published>
    <updated>2020-03-19T00:37:33.739Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子隐形传态过程。<br><a id="more"></a></p><h2 id="量子隐形传态"><a href="#量子隐形传态" class="headerlink" title="量子隐形传态"></a>量子隐形传态</h2><p>Alice和Bob的粒子处于纠缠态$\left|\beta_{00}\right&gt;$，Alice需要将态$\left|\psi\right&gt;$传递给Bob，步骤如下：</p><ol><li>Alice对手中的两个比特做用CNOT门</li><li>Alice对手中的第一个比特作用Hadamard门</li><li>Alice测量出两个比特，并把结果告诉Bob</li><li>Bob根据Alice的测量结果分别作用X门和Z门到自己手中的比特上即可</li></ol><p><img src="/img/telepotation.png" alt="量子隐形传态"></p><p>实际上，可以将测量放在$X,Z$操作之后，其原因是，对前两个比特的测量不影响第三个比特的约化密度矩阵。<br><img src="/img/telepotation2.png" alt="量子隐形传态2"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;量子隐形传态过程。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="量子隐形传态" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E9%9A%90%E5%BD%A2%E4%BC%A0%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Notes on Quantum Information - 零碎知识点</title>
    <link href="https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://github.com/donghufeng/2020/03/16/Notes-on-Quantum-Information-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2020-03-16T04:00:22.000Z</published>
    <updated>2020-03-19T03:04:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>记录零碎知识点。<br><a id="more"></a></p><h2 id="模二加法"><a href="#模二加法" class="headerlink" title="模二加法"></a>模二加法</h2><p>模二加法$\oplus$是不考虑进位的加法，是加法运算的子集，等同于异或，满足交换律结合律</p><script type="math/tex; mode=display">a\oplus a=0, 0\oplus a=a,1\oplus a=\bar{a}</script><h2 id="单比特任意门分解"><a href="#单比特任意门分解" class="headerlink" title="单比特任意门分解"></a>单比特任意门分解</h2><script type="math/tex; mode=display">\begin{aligned}    U&=e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)\\    &=e^{i\alpha}AXBXC\\    &=e^{i\alpha}R_{\vec{n}}(\theta)\end{aligned}</script><p>上式中：</p><script type="math/tex; mode=display">\begin{aligned}    A&=R_z(\beta)R_y(\gamma/2)\\    B&=R_y(-\gamma/2)R_z(-(\delta+\beta)/2)\\    C&=R_z((\delta-\beta)/2)\\    I&=ABC\end{aligned}</script><h2 id="贝尔态"><a href="#贝尔态" class="headerlink" title="贝尔态"></a>贝尔态</h2><p>先作用Hadmard门，再作用和CNOT门。</p><script type="math/tex; mode=display">\left|\beta_{xy}\right>=\frac{\left|0,y\right>+(-1)^x \left|1,\bar{y}\right>}{\sqrt{2}}</script><p>产生贝尔态的线路：<br><img src="/img/generate_bell_state.png" alt="generate bell state"></p><p>贝尔基测量：<br><img src="/img/bell_basis_measurement.png" alt="bell_basis_measurement"><br>与产生贝尔基矢的线路互逆，（基矢的变换与系数的变换互逆）。</p><h2 id="不同总类的算符"><a href="#不同总类的算符" class="headerlink" title="不同总类的算符"></a>不同总类的算符</h2><ul><li>Hermitian</li></ul><script type="math/tex; mode=display">A=A^\dagger</script><ul><li>Unitary</li></ul><script type="math/tex; mode=display">UU^\dagger=I</script><ul><li>Normal</li></ul><script type="math/tex; mode=display">AA^\dagger=A^\dagger A</script><ul><li>Positive</li></ul><script type="math/tex; mode=display">\left<v\right|A\left|v\right>\ge 0, \text{for any} \left|v\right></script><ul><li>Positive definite</li></ul><script type="math/tex; mode=display">\left<v\right|A\left|v\right> > 0, \text{for any} \left|v\right></script><ul><li>Projector</li></ul><script type="math/tex; mode=display">P=\sum_{i=1}^k \left|i\right>\left<i\right|</script><h2 id="门转换"><a href="#门转换" class="headerlink" title="门转换"></a>门转换</h2><ul><li>控制Z门</li></ul><script type="math/tex; mode=display">\text{C}Z(0,1)=\text{C}Z(1,0)</script><p><img src="/img/cz.png" alt="CZ"></p><ul><li>Hadmard门和CNOT门</li></ul><script type="math/tex; mode=display">H^{\otimes 2}\text{CNOT}(0,1)H^{\otimes 2}=\text{CNOT}(1,0)</script><p><img src="/img/hcnot.png" alt="Hadmard and CNOT"></p><ul><li>控制U门</li></ul><p><img src="/img/cu.png" alt="CU"></p><ul><li>Trotter定理</li></ul><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}(e^{iAt/n}e^{iBt/n})^n=e^{i(A+B)t}</script><ul><li>等分圆求和</li></ul><script type="math/tex; mode=display">\sum_{j=0}^{N-1} e^{2\pi i s j /N}=N\delta_{s0}, s\in \mathbf{N}.</script><p><strong>解释：</strong><br>在复平面内将圆等分$N$分，每次取$sj$分并进行求和，总能将所有等分点取到，如果$s\neq 0$，则求和后为零。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Notes on &lt;em&gt;Quantum Computation and Quantum Information&lt;/em&gt;.&lt;br&gt;记录零碎知识点。&lt;br&gt;
    
    </summary>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/categories/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
    
      <category term="量子信息" scheme="https://github.com/donghufeng/tags/%E9%87%8F%E5%AD%90%E4%BF%A1%E6%81%AF/"/>
    
      <category term="模二加法" scheme="https://github.com/donghufeng/tags/%E6%A8%A1%E4%BA%8C%E5%8A%A0%E6%B3%95/"/>
    
      <category term="门分解" scheme="https://github.com/donghufeng/tags/%E9%97%A8%E5%88%86%E8%A7%A3/"/>
    
      <category term="贝尔态" scheme="https://github.com/donghufeng/tags/%E8%B4%9D%E5%B0%94%E6%80%81/"/>
    
      <category term="算符分类" scheme="https://github.com/donghufeng/tags/%E7%AE%97%E7%AC%A6%E5%88%86%E7%B1%BB/"/>
    
      <category term="Trotter定理" scheme="https://github.com/donghufeng/tags/Trotter%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
</feed>
