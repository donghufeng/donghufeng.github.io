<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>新机配置流程</title>
      <link href="/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/03/30/%E6%96%B0%E6%9C%BA%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="装机流程"><a href="#装机流程" class="headerlink" title="装机流程"></a>装机流程</h1><ul><li>安装pip</li></ul><p><code>sudo apt install python3-pip</code></p><ul><li>生存ssh密钥</li></ul><p><code>ssh-keygen -t rsa -C &quot;your@email&quot;</code></p><ul><li><p>下载vscode</p></li><li><p>下载setting-sync插件</p></li></ul><p>Gist id: e7084f25b33de90bddd1a98977971d41</p><p>token: xxxx</p><ul><li>免费ssr</li></ul><p>ssr://NDUuMTM2LjI0NC4yMDU6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6Wkdab1oyWnE</p><p>ssr://NDUuMTI5LjMuMTMxOjQ0MzphdXRoX2FlczEyOF9tZDU6YWVzLTI1Ni1jdHI6dGxzMS4yX3RpY2tldF9hdXRoOmFtaGtaMmhrWm1j</p><p>ssr://NDUuMTI5LjMuNTc6NDQzOmF1dGhfYWVzMTI4X21kNTphZXMtMjU2LWN0cjp0bHMxLjJfdGlja2V0X2F1dGg6WjJabmFHZG1jMlJvYVd0cWVYVnlaUQ</p><p>ssr下载地址：</p><ol><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fdrive.google.com%2Fopen%3Fid%3D1CHtnhotLbdVn2Ytiv4bMD1ZnZxoeWfnf</a></p></li><li><p><a href="https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc" target="_blank" rel="noopener">https://www.youtube.com/redirect?v=hl2h0F9YXbs&amp;redir_token=Y6lGPa5MPTGE5i9ppaAtWndSYPF8MTU4NTUzNjc4OUAxNTg1NDUwMzg5&amp;event=video_description&amp;q=https%3A%2F%2Fwww.lanzous.com%2Fi8gvstc</a></p></li></ol><h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><ol><li>安装ss客户端</li></ol><p><code>pip install git+https://github.com/shadowsocks/shadowsocks.git@master</code></p><ol><li>ss配置文件</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"XXXXXXX"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: XXXXXX,</span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,</span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">1080</span>,</span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"XXXXXX"</span>,</span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"aes-256-gcm"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地地址为<code>127.0.0.1</code>，端口为<code>1080</code>。</p><ol><li>启动ss</li></ol><p><code>sslocal -c /xxx/xxx/sslocal-config.json &amp;</code></p><h2 id="privoxy"><a href="#privoxy" class="headerlink" title="privoxy"></a>privoxy</h2><p>ss是socks5协议，需要做http转发，供整个系统使用</p><ol><li>安装privoxy</li></ol><p><code>sudo apt install privoxy</code></p><ol><li>配置privoxy</li></ol><p>在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen-address 127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>表示privoxy对本机的代理端口为<code>8118</code>。</p><p>如果需要全局代理，则在<code>/etc/privoxy/config</code>中添加或者取消注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 / 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的http请求都使用本机的1080端口的socks5协议来转发。</p><p>如果需要局部代理，则注释掉上面全局代理的那行，加上：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">forward-socks5 .google.com 127.0.0.1:1080 .</span><br></pre></td></tr></table></figure><p>表示所有的<code>.google.com</code>的http请求都从本机的1080端口转发，而其他的网站则不做代理。</p><p>同时也可以通过文件的方式制定更多的网站代理。复制<code>gfwlist.action</code>到<code>/etc/privoxy</code>目录下，并在该目录下的设置文件<code>config</code>中添加：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">actionsfile gfwlist.action</span><br></pre></td></tr></table></figure><p>表明该文件中的网站都做代理。</p><ol><li>启动privoxy</li></ol><p><code>sudo service privoxy start</code></p><p>该命令是开机自动启动，因此下次开机不需要运行。</p><ol><li>设置本机代理</li></ol><p>在本机的网络代理设置中选择手动配置代理服务器，将本机的http请求都通过privoxy来代理。对所有协议都选择地址为<code>127.0.0.1</code>端口为<code>8118</code>。</p><ol><li>终端也能利用ss</li></ol><p>对终端的网络也设置代理，在全局变量中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy=<span class="string">"http://127.0.0.1:8118"</span></span><br><span class="line"><span class="built_in">export</span> https_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="variable">$proxy</span></span><br><span class="line"><span class="built_in">export</span> ftp_proxy=<span class="variable">$proxy</span></span><br></pre></td></tr></table></figure><p>可在<code>～/.bashrc</code>或者<code>/etc/profile</code>中添加上述指令。</p><p>梳理一下流程，通过设置本机代理，将本机的所有<code>http</code>请求都利用<code>privoxy</code>来进行转发。<code>privoxy</code>则根据规则选择性地将http请求转为shadowsocks的socks5协议向目标网站获得数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/03/29/hello-world/"/>
      <url>/2020/03/29/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>$\alpha$</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>python - 类</title>
      <link href="/2020/03/21/python-%E7%B1%BB/"/>
      <url>/2020/03/21/python-%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>介绍python面向对象编程时的一些方法。<br><a id="more"></a></p><h2 id="抽象方法、类方法和静态方法"><a href="#抽象方法、类方法和静态方法" class="headerlink" title="抽象方法、类方法和静态方法"></a>抽象方法、类方法和静态方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %%</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""person</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setdoc</span><span class="params">(cls,doc)</span>:</span></span><br><span class="line">        cls.__doc__=doc</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sayhi</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"hi"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">woman</span><span class="params">(person)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    woman</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        person.__init__(self)</span><br><span class="line">        self.sex=<span class="string">'woman'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name=name</span><br><span class="line"></span><br><span class="line"><span class="comment"># %%</span></span><br><span class="line">alice=woman()</span><br><span class="line"></span><br><span class="line"><span class="comment"># staticmethod</span></span><br><span class="line">alice.sayhi() <span class="comment">#hi</span></span><br><span class="line">woman.sayhi() <span class="comment">#hi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># classmethod</span></span><br><span class="line">print(alice.__doc__) <span class="comment">#woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#woman</span></span><br><span class="line">alice.setdoc(<span class="string">"set by alice"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by alice</span></span><br><span class="line">woman.setdoc(<span class="string">"set by woman"</span>)</span><br><span class="line">print(alice.__doc__) <span class="comment">#set by woman</span></span><br><span class="line">print(woman.__doc__) <span class="comment">#set by woman</span></span><br><span class="line"><span class="comment"># %%</span></span><br></pre></td></tr></table></figure><p><code>@abstractmethod</code>:</p><p>必须被子类重新实现，否者在实例化时就会报错</p><p><code>@classmethod</code>:</p><p>类方法可通过实例调用，也可通过类直接调用，改变的是类本身的参数，类方法的第一个关键字是cls</p><p><code>@staticmethod</code></p><p>静态方法，可通过类本身或者实例来调用，不会改变类或者实例本身的任何东西，但是该方法隶属于该类，这么写是为了方便代码组织。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 抽象方法 </tag>
            
            <tag> 类方法 </tag>
            
            <tag> 静态方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quantum Chemistry - Basic</title>
      <link href="/2020/03/20/Quantum-Chemistry-Basic/"/>
      <url>/2020/03/20/Quantum-Chemistry-Basic/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Modern Quantum Chemistry</em>.<br>基本知识。</p><a id="more"></a><h2 id="原子单位"><a href="#原子单位" class="headerlink" title="原子单位"></a>原子单位</h2><p>原子单位是为了进行无量纲处理。氢原子的电子波动方程可写为：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e}\nabla^2-\frac{e^2}{4\pi\varepsilon_0r}\right]\phi=E\phi</script><p>对长度进行无量纲化，取$r=\lambda r’$，代入上式可得：</p><script type="math/tex; mode=display">\left[-\frac{\hbar^2}{2m_e \lambda^2}\nabla'^2-\frac{e^2}{4\pi\varepsilon_0r'\lambda}\right]\phi=E\phi</script><p>令:</p><script type="math/tex; mode=display">\frac{\hbar^2}{m_e \lambda^2}=\frac{e^2}{4 \pi \varepsilon_0 \lambda}=E_a</script><p>称$E_a$为一个<em>Hartree</em>，约为$27.211\text{eV}$，由上式可得：</p><script type="math/tex; mode=display">\lambda=\frac{4 \pi\varepsilon_0 \hbar^2}{m_e e^2}=a_0</script><p>称$a_0$为玻尔半径，约为0.52918埃。经过单位转化过后，薛定谔方程变为：</p><script type="math/tex; mode=display">\left(-\frac{1}{2} \nabla'^2-\frac{1}{r'}\right)\phi'=E'\phi'</script><p>因此在原子单位里，能力的单位为一个Hartree $E_a$，长度的单位为一个波尔半径$a_0$。</p><h2 id="多体相互作用哈密顿量"><a href="#多体相互作用哈密顿量" class="headerlink" title="多体相互作用哈密顿量"></a>多体相互作用哈密顿量</h2><p>对于$M$个原子和$N$个电子的系统，其哈密顿量在原子单位下可写为：</p><script type="math/tex; mode=display">\begin{aligned}H&=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{A=1}^{M}\frac{1}{2M_A}\nabla _{A}^{2}-\sum_{i=1}^{M}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}\\&+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}\end{aligned}</script><h2 id="电子哈密顿量"><a href="#电子哈密顿量" class="headerlink" title="电子哈密顿量"></a>电子哈密顿量</h2><p>由于原子比电子重很多，因此可以近似认为原子是不动的，只有电子在原子所形成的场中运动，那么原子的动能将为被忽略，而原子之间的相互作用将为常数，因此哈密顿量可以简化为：</p><script type="math/tex; mode=display">H_\text{elec}=-\sum_{i=1}^{N}\frac{1}{2}\nabla _{i}^{2}-\sum_{i=1}^{N}\sum_{A=1}^{M}\frac{Z_A}{r_{iA}}+\sum_{i=1}^{N}\sum_{j>i}^{N}\frac{1}{r_{ij}}</script><p>并称其为电子哈密顿量。设其本征值为$E_\text{elec}$，那么系统总能量是电子能量和原子排斥能之和，则为：</p><script type="math/tex; mode=display">E_ \text{tot}=E_ \text{elec}+\sum_{A=1}^{M}\sum_{B>A}^{M}\frac{Z_AZ_B}{R_{AB}}</script><h2 id="泡利不相容原理"><a href="#泡利不相容原理" class="headerlink" title="泡利不相容原理"></a>泡利不相容原理</h2><p>电子具有$1/2$自旋，因此电子的坐标是由位置坐标和自旋方向构成：</p><script type="math/tex; mode=display">x=\{r,w\}</script><p>泡利不相容原理说，电子波函数中，交换两个电子不能同时处于同意空间位置，因此有：</p><script type="math/tex; mode=display">\Phi \left(x_1,\cdots,x_i,\cdots,x_j,\cdots,x_n\right)=-\Phi \left(x_1,\cdots,x_j,\cdots,x_i,\cdots,x_n\right)</script><h2 id="单电子波函数"><a href="#单电子波函数" class="headerlink" title="单电子波函数"></a>单电子波函数</h2><p>单电子波函数由空间波函数和自旋波函数构成：</p><script type="math/tex; mode=display">\chi(x)=\psi(r) \left|+\right> \text{or } \psi(r) \left|-\right></script><p>对于多电子哈密顿量来说，如果忽略电子之间的排斥力，则多电子波函数是单电子波函数的乘积构成，称为<strong>Hartree Product</strong>。但是该波函数不满足泡利反对称性，因此需要通过如下方法构造。</p><h2 id="Slater-Determinats"><a href="#Slater-Determinats" class="headerlink" title="Slater Determinats"></a>Slater Determinats</h2><p>联想到在矩阵求秩时，任意交换两行则秩会反号，因此可通过求单电子波函数构成的矩阵的秩的方法来求多电子波函数的满足反对称性的波函数。</p><script type="math/tex; mode=display">\Psi(x_1,\cdots,x_N)=\frac{1}{\sqrt{N!}} \begin{vmatrix}\chi_i(x_1)&\chi_j(x_1)&\cdots&\chi_k(x_1)\\\chi_i(x_2)&\chi_j(x_2)&\cdots&\chi_k(x_2)\\\vdots&\vdots&&\vdots\\\chi_i(x_N)&\chi_j(x_N)&\cdots&\chi_k(x_N)\end{vmatrix}</script><p>并简写为：</p><script type="math/tex; mode=display">\Psi= \left|\chi_i\chi_j\cdots\chi_k\right></script>]]></content>
      
      
      <categories>
          
          <category> Quantum Chemistry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算化学 </tag>
            
            <tag> 原子单位 </tag>
            
            <tag> Hartree </tag>
            
            <tag> 波尔半径 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 阶查找</title>
      <link href="/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/"/>
      <url>/2020/03/19/Notes-on-Quantum-Information-%E9%98%B6%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子阶查找算法。<br><a id="more"></a></p><h2 id="阶查找算法"><a href="#阶查找算法" class="headerlink" title="阶查找算法"></a>阶查找算法</h2><p>对于两个正整数 $x,N,x&lt;N $，该算法能找到最小的整数$r$，且满足$x^r=1(\text{mod } N)$。利用相位估计算法可以近似求解改问题。</p><p>假设有酉算符满足：</p><script type="math/tex; mode=display">U \left|y\right>=\left|xy(\text{mod }N)\right></script><p>$U$的本征态为$\left|u_s\right&gt;$，且有：</p><script type="math/tex; mode=display">\left|u_s\right>=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right></script><p>下面证明改态确实是$U$的本征态。</p><script type="math/tex; mode=display">\begin{aligned}U \left|u_s\right>&=\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\\&=e^{2\pi is/r}\frac{1}{\sqrt{r}}\sum_{k=0}^{r-1}\exp \left[\frac{-2\pi is (k+1)}{r}\right]\left|x^{k+1}(\text{mod }N)\right>\end{aligned}</script><p>又因为：</p><script type="math/tex; mode=display">\exp \left[\frac{-2\pi is r}{r}\right]\left|x^r(\text{mod }N)\right>=\left|1(\text{mod }N)\right>=\exp \left[\frac{-2\pi is 0}{r}\right]\left|x^0(\text{mod }N)\right></script><p>所以：</p><script type="math/tex; mode=display">U \left|u_s\right>=\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right></script><p>因此，可以利用相位估计算法，得到$s/r$，并计算得到阶数$r$。然而，在相位估计算法中，第二个寄存器所需要构造的态$\left|u_s\right&gt;$中已经包含$r$，这不合理。注意到：</p><script type="math/tex; mode=display">\begin{aligned}\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\left|u_s\right>&=\frac{1}{r}\sum_{k=0}^{r-1}\sum_{s=0}^{r-1}\exp \left[\frac{-2\pi is k}{r}\right]\left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{k0}\left|x^k(\text{mod }N)\right>\\&=\left|1\right>\end{aligned}</script><p>可以将第二个寄存器的处态制备为全$\left|1\right&gt;$，此时：</p><script type="math/tex; mode=display">\begin{aligned}U \left|1\right>&=\frac{1}{\sqrt{r}}\sum_{s=0}^{r-1}\exp \left[\frac{2\pi is}{r}\right] \left|u_s\right>\\&=\frac{1}{r}\sum_{s=0}^{r-1}\sum_{k=0}^{r-1}\exp \left[\frac{2\pi is(1-k)}{r}\right] \left|x^k(\text{mod }N)\right>\\&=\frac{1}{r}\sum_{k=0}^{r-1}r\delta_{1k} \left|x^k(\text{mod }N)\right>\\&=\left|x\right>\end{aligned}</script><blockquote><p>此处存疑，$\left|1\right&gt;$不是$U$的本征态！相位估计该怎么做？？？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 阶查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 相位估计</title>
      <link href="/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/"/>
      <url>/2020/03/18/Notes-on-Quantum-Information-%E7%9B%B8%E4%BD%8D%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子相位估计算法。<br><a id="more"></a></p><h2 id="相位估计问题"><a href="#相位估计问题" class="headerlink" title="相位估计问题"></a>相位估计问题</h2><p>假设有酉算符$U$，其本征态为$\left|u\right&gt;$，对应的本征值为$e^{2\pi i\varphi}$，相位估计算法可以对$\varphi$进行指定精度的估计，注意，这里$0\le\varphi\le1$。改算法第一个步骤的线路图如下：</p><p><img src="/img/pe.png" alt="相位估计"></p><p>图中上半部分的寄存器由$t$个比特构成，下半部分的寄存器存储的是本征态$\left|u\right&gt;$。首先对第一个寄存器作用$H^{\otimes t}$，然后依次选择第$j$个比特对第二个寄存器做受控$U^{2^j-1}$操作。因此第一个寄存器的态为：</p><script type="math/tex; mode=display">H^{\otimes t}\left|0\right>^{\otimes t}=\frac{1}{\sqrt{2^t}}\sum_j \left|j\right>=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1}\left|j_1\cdots j_{t}\right></script><p>作用第一个控制门：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_1\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t-1}=0}^{1} \left|j_1\cdots j_{t-1}\right>\left(\left|0\right>+e^{2\pi i \varphi(2^0 )}\left|1\right>\right)\\&=\frac{1}{\sqrt{2}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第二个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_2\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{t-1}2^1+j_t 2^0)}\left|j_1\cdots j_{t}\right>\end{aligned}</script><p>作用第$t$个控制门后：</p><script type="math/tex; mode=display">\begin{aligned}\left|\psi_{t}\right>&=\frac{1}{\sqrt{2^t}}\sum_{j_1=0}^{1}\cdots\sum_{j_{t}=0}^{1} e^{2\pi i \varphi(j_{1}2^{t-1}+j_t 2^0)}\left|j_1\cdots j_{t}\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi j}\left|j\right>\\&=\frac{1}{\sqrt{2^t}}\sum_{j=0}^{2^t-1}e^{2\pi i\varphi\cdot 2^t j/2^t}\left|j\right>\end{aligned}</script><p>可见第一个寄存器的末态是对$\left|2^t\varphi\right&gt;$进行傅里叶变换得到的，因此，如果$\varphi$可以写为$\varphi=0.\varphi_1\cdots\varphi_t$时，对其作用傅里叶逆变换将得到$\varphi$的精确值。如果不能精确写出此形式，则可以在$2^{-n}$的精确度下近似得到$\varphi$，此时所需的比特数为：</p><script type="math/tex; mode=display">t=n+\left\lceil\log \left(2+\frac{1}{2\epsilon}\right)\right\rceil.</script><p>整体的线路图为：</p><p><img src="/img/pe2.png" alt="相位估计2"></p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 相位估计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍平一个矩阵</title>
      <link href="/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/"/>
      <url>/2020/03/16/%E6%8B%8D%E5%B9%B3%E4%B8%80%E4%B8%AA%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<p>如何拍平一个矩阵？<br><a id="more"></a></p><ul><li><code>x.flatten</code></li><li><code>x.revel</code></li><li><code>x.reshape(-1)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 各种分解</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E5%90%84%E7%A7%8D%E5%88%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍矩阵的各种分解。<br><a id="more"></a></p><h2 id="极分解-Polar-decomposition"><a href="#极分解-Polar-decomposition" class="headerlink" title="极分解(Polar decomposition)"></a>极分解(Polar decomposition)</h2><p>对于$V$空间中的任意算符$A$，能将其按照如下形式分解</p><script type="math/tex; mode=display">A=UJ=KU</script><p>其中，$U$为酉矩阵，且$J$为半正定矩阵，$J=\sqrt{A^\dagger A}$，$K=\sqrt{AA^\dagger}$，如果$A$可逆，则$U$唯一。<br><strong>证明：</strong></p><ol><li>取$V$空间的一组基矢$\left|i\right&gt;$和任意态$\left|v\right&gt;$，则：<script type="math/tex; mode=display">\left<v\right|A^\dagger A \left|v\right>=\sum_i\left|a_i\right|^2\ge 0</script>因此$A^\dagger A$是对称半正定矩阵，$\sqrt{A^\dagger A}$也是对称半正定矩阵。</li><li>根据谱定理，对于半正定矩阵有：<br><script type="math/tex">J=\sqrt{A^\dagger A}=\sum_i \lambda_i \left|i\right>\left<i\right|(\lambda_i\ge0)</script>。</li><li>定义$\left|\psi_i\right&gt;=A \left|i\right&gt;$，因此有：<br><script type="math/tex">\left<\psi_i\mid \psi_i\right>=\left<i\right|A^\dagger A\left|i\right>=\lambda_i^2</script>。</li><li>对于$\lambda_i\neq 0$的态，定义$\left|e_i\right&gt;=\left|\psi_i\right&gt;/\lambda_i$，因此$\left|e_i\right&gt;$是彼此正交的单位矢量。</li><li>利用Schmidt正交化方法对$\left|e_i\right&gt;$进行扩充，使得其为$V$中的基矢，并仍然记为$\left|e_i\right&gt;$。</li><li>定义酉算符$U=\sum_i \left|e_i\right&gt;\left&lt;i\right|$。</li><li>对于$\lambda_i\neq 0$的那些态，有<br><script type="math/tex">UJ \left|i\right>=\lambda_i U \left|i\right>=\lambda_i \left|e_i\right>=\left|\psi_i\right>=A \left|i\right></script>。</li><li>对于$\lambda_i =0$的态来说，有<script type="math/tex; mode=display">UJ \left|i\right>=0=\left|\psi_i\right>=A \left|i\right></script></li></ol><p>综上，$A=UJ$。此时，$A=UJ=UJU^\dagger U=KU$，且$K=UJU^\dagger=K^\dagger$，此时</p><script type="math/tex; mode=display">AA^\dagger=KUU^\dagger K^\dagger=K^2</script><p>所以$K=\sqrt{AA^\dagger}$。</p><h2 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h2><p>对于任意方矩阵，总可以按照如下分解，</p><script type="math/tex; mode=display">A=UDV</script><p>其中，$U$和$V$是酉矩阵，$D$是对角矩阵，称为$A$的奇异值。<br><strong>证明：</strong></p><ol><li>根据极分解，$A=SJ$，其中$S$为酉矩阵，$J$为半正定矩阵。</li><li>根据谱分解定理，$J=TDT^\dagger$，其中$T$为酉矩阵，$D$为对角矩阵。</li><li>由上：<script type="math/tex; mode=display">A=SJ=STDT^\dagger</script></li></ol><p>因此有$U=ST$，$V=T^\dagger$。</p><h2 id="Schmidt分解"><a href="#Schmidt分解" class="headerlink" title="Schmidt分解"></a>Schmidt分解</h2><p>复合系统$AB$中的纯态$ \left|\psi\right&gt; $总能按如下分解：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_i \lambda_i \left|i_A\right> \left|i_B\right></script><p>其中$ \left|i_A\right&gt; $和$ \left|i_B\right&gt; $分别为两个子系统的正交归一基矢，且$\lambda_i$是正实数，满足归一化条件$\sum_i\lambda_i^2=1$。</p><p><strong>证明：</strong></p><p>这里假设两个子系统的空间维度一样，并且取两个子系统的任意正交归一基矢为$ \left|j\right&gt; $和$ \left|k\right&gt; $，则复合空间$AB$中的纯态$ \left|\psi\right&gt; $可按照子空间的基矢展开：</p><script type="math/tex; mode=display">\left|\psi\right> =\sum_{jk}a_{jk} \left|j\right> \left|k\right></script><p>系数矩阵$a$为方阵，可进行奇异值分解$a=udv$，因此：</p><script type="math/tex; mode=display">\left|\psi\right>=\sum_{ijk} u_{ji}d_{ii}v_{ik}\left|j\right> \left|k\right></script><p>令$ \left|i_A\right&gt;=\sum_ju_{ji} \left|j\right&gt;, \left|i_B\right&gt;=\sum_k v_{ik} \left|k\right&gt;, \lambda_i=d_{ii} $，即可得到满足条件的分解。此时有</p><script type="math/tex; mode=display">\begin{aligned}    \rho^A&=\text{tr}_B(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_A\right>\left<i_A\right|\\    \rho^B&=\text{tr}_A(\left|\psi\right>\left<\psi\right|)=\sum_i \lambda_i^2 \left|i_B\right>\left<i_B\right|\end{aligned}</script><p>易知，$ \left|i_X\right&gt; $为纯态$ \left|\psi\right&gt; $在子系统$X$中的约化密度矩阵$\rho^X$的本征态，$\lambda_i^2$为两个子系统约化密度矩阵的共同本征值。</p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 极分解 </tag>
            
            <tag> 奇异值分解 </tag>
            
            <tag> Schmidt分解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 密度算符与迹</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E5%AF%86%E5%BA%A6%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%BF%B9/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>记录零碎知识点。<br><a id="more"></a></p><h2 id="密度矩阵"><a href="#密度矩阵" class="headerlink" title="密度矩阵"></a>密度矩阵</h2><p>混态不能用一个态标识出来，系统中出现态$\left|\psi_i\right&gt;$的概率为$p_i$，密度矩阵可写为：</p><script type="math/tex; mode=display">\rho=\sum_i^np_i \left|\psi_i\right>\left<\psi_i\right|</script><p>这里当$n=1$是为纯态密度矩阵。可观察量$A$在混态中的期望值为：</p><script type="math/tex; mode=display">E(A)=\sum_i^n p_i \left<\psi_i\right|A\left|\psi_i\right>=\text{tr}(\rho A)</script><p>纯态也有相同结果 。</p><p>混态的$\text{tr}(\rho^2)&lt;1$：</p><script type="math/tex; mode=display">\text{tr}(\rho^2)=\sum_{i,j}p_j^2 \left<i\mid \psi_j\right> \left<\psi_j\mid i\right>\le\sum_i p_i^2<\sum_i p_i=1</script><p>对于纯态来说：</p><script type="math/tex; mode=display">\left|\psi\right>=\cos\frac{\theta}{2} \left|0\right>+e^{i\varphi}\sin{\frac{\theta}{2}} \left|1\right></script><p>其密度矩阵为：</p><script type="math/tex; mode=display">\begin{aligned}\rho&= \left|\psi\right>\left<\psi\right|\\&= \begin{pmatrix}\cos^2\frac{\theta}{2}&\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{-i\varphi}\\\cos\frac{\theta}{2}\sin\frac{\theta}{2}e^{i\varphi}&\sin^2\frac{\theta}{2}\end{pmatrix}\\&= \frac{1}{2}\begin{pmatrix}1+\cos\theta&\sin\theta e^{-i\varphi}\\\sin\theta e^{i\varphi}&1-\cos\theta\end{pmatrix}\\&=\frac{I+\vec{r}\cdot \vec{\sigma}}{2}\end{aligned}</script><p>对于混态来说，有$\rho=\sum_i p_i \rho_i$，因此，也有上述的形式。</p><h2 id="迹"><a href="#迹" class="headerlink" title="迹"></a>迹</h2><p>对于任意算符$A$，和一组正交基矢$\left|i\right&gt;$,迹的定义为：</p><script type="math/tex; mode=display">\text{tr}(A)=\sum_i \left<i\right|A\left|i\right>=\sum_i A_{ii}</script><p>取任意态$\left|\psi\right&gt;$，则有$\text{tr}(A \left|\psi\right&gt;\left&lt;\psi\right|)=\left&lt;\psi\right|A\left|\psi\right&gt;$，证明如下：</p><script type="math/tex; mode=display">\text{tr}(A \left|\psi\right>\left<\psi\right|)=\sum_i \left<i\right|A\left|\psi\right> \left<\psi\mid i\right>=\sum_i  \left<\psi\mid i\right>\left<i\right|A\left|\psi\right>=\left<\psi\right|A\left|\psi\right></script><h2 id="约化密度矩阵和偏迹"><a href="#约化密度矩阵和偏迹" class="headerlink" title="约化密度矩阵和偏迹"></a>约化密度矩阵和偏迹</h2><script type="math/tex; mode=display">\rho^A=\text{tr}_B(\rho^{AB})</script><p>e.g.:</p><script type="math/tex; mode=display">\text{tr}_B(\left|a_1\right>\left<a_2\right|\otimes \left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right|\text{tr}(\left|b_1\right> \left<b_2\right|)=\left|a_1\right>\left<a_2\right| \left<b_2\mid b_1\right></script>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 密度矩阵 </tag>
            
            <tag> 迹 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - Cauchy-Schwarz不等式</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-Cauchy-Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍Cauchy-Schwarz不等式。<br><a id="more"></a></p><h2 id="Cauchy-Schwarz不等式"><a href="#Cauchy-Schwarz不等式" class="headerlink" title="Cauchy-Schwarz不等式"></a>Cauchy-Schwarz不等式</h2><p>希尔伯特空间中的两个态矢量$\left|v\right&gt;$和$\left|w\right&gt;$，则有：</p><script type="math/tex; mode=display">\left| \left<v\mid w\right>\right|^2\le \left<v\mid v\right> \left<w\mid w\right></script><p><strong>证明：</strong><br>在希尔伯特空间中选择一组基矢$\left|i\right&gt;$，并使得该组基矢的第一个为</p><script type="math/tex; mode=display">\left|w\right>/\sqrt{\left<w\mid w\right>}</script><p>因此：</p><script type="math/tex; mode=display">\begin{aligned}\left<v\mid v\right>\left<w\mid w\right>&=\sum_i \left<v\mid i\right>\left<i\mid v\right>\left<w\mid w\right>\\&\ge\frac{\left<v\mid w\right>\left<w\mid v\right>}{\left<w\mid w\right>}\left<w\mid w\right>\\&=\left|\left<v\mid w\right>\right|^2\end{aligned}</script><p>取$\ge$是因为求和中只取第一个基矢，而忽略掉有剩余基矢得到的数（为正数）。</p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> Cauchy-Schwarz不等式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo注意事项</title>
      <link href="/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2020/03/16/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>Hexo使用过程中的注意事项。<br><a id="more"></a></p><ul><li>大括号{}问题。</li></ul><p>在公式中，如果要显示”{}”，需要加两个”//“，如$\{\}$。</p><ul><li>量子态问题</li></ul><p>如果一段话中有两个态矢量，且里面的字母有大括号包围的下脚标，需要将”_<em>“改为”\_</em>“，如：</p><p>$\left|a_{0}\right&gt;$b$\left|c_{1}\right&gt;.$</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 量子傅里叶变换</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子傅里叶变换算法。<br><a id="more"></a></p><!-- slide --><h2 id="经典离散傅里叶算法"><a href="#经典离散傅里叶算法" class="headerlink" title="经典离散傅里叶算法"></a>经典离散傅里叶算法</h2><p>对于数据点集合$A=\{A_i,i=0,N-1\}$，其离散傅里叶变化为</p><script type="math/tex; mode=display">B_j=\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}{e^{2\pi i jk/N}A_k}</script><!-- slide --><h2 id="量子离散傅里叶算法"><a href="#量子离散傅里叶算法" class="headerlink" title="量子离散傅里叶算法"></a>量子离散傅里叶算法</h2><p>n比特的态可以表示成$\left|j_1j_2…j_n\right&gt;$，可将态看着二进制数，从而也可将态写成十进制数表示为$\left|j\right&gt;$，其中</p><script type="math/tex; mode=display">j=[j_1\cdots j_n]=j_1 * 2^{n-1}+j_i*2^{n-i}+j_n</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">3</span></span><br><span class="line">s=<span class="string">'111'</span></span><br><span class="line">k=int(s,<span class="number">2</span>) <span class="comment"># 参数2用来表示从二进制转化为十进制</span></span><br><span class="line">s==bin(k)[<span class="number">2</span>:].zfill(n) <span class="comment">#bin函数用来转化为二进制，zfill函数用来补零</span></span><br></pre></td></tr></table></figure><!-- slide --><p>对于二进制的分数表示$0.j_1j_2\cdots j_n$，其表示为十进制为</p><script type="math/tex; mode=display">[0.j_1j_2\cdots j_n]=j_1*2^{-1}+\cdots+j_n*2^{-n}=\sum_{k=1}^{n}j_k*2^{-k}.</script><p>我们有$[0.j_1\cdots j_n]=[j_1\cdots j_n]/2^n.$</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">3</span></span><br><span class="line">s=<span class="string">'0.011'</span></span><br><span class="line">k=int(s[<span class="number">2</span>:],<span class="number">2</span>)/<span class="number">2</span>**n</span><br><span class="line">s==<span class="string">'0.'</span>+bin(int(k*<span class="number">2</span>**n))[<span class="number">2</span>:].zfill(n)</span><br></pre></td></tr></table></figure><!-- slide --><p>对于态$\left|j\right&gt;$，其傅里叶变换定义为</p><script type="math/tex; mode=display">\left|j\right>\rightarrow\frac{1}{\sqrt{N}}\sum_{k=0}^{N-1}e^{2\pi i jk/N}\left|k\right>,</script><p>其中$N=2^n$，设$\omega_n=e^{\frac{2\pi i}{2^n}}$其矩阵表示为，</p><script type="math/tex; mode=display">\begin{pmatrix}\left|0\right>\\\vdots\\\left|j\right>\\\vdots\\\left|N-1\right>\end{pmatrix}=\frac{1}{\sqrt{N}}\begin{pmatrix}1&\cdots&1&\cdots&1\\\vdots&\cdots&\vdots&\cdots&\vdots\\1&\cdots&\omega_n^{j k}&\cdots&\omega_n^{j (N-1)}\\\vdots&\cdots&\vdots&\cdots&\vdots\\1&\cdots&\omega_n^{(N-1)k}&\cdots&\omega_n^{(N-1)^2}\\\end{pmatrix}\begin{pmatrix}\left|0\right>\\\vdots\\\left|k\right>\\\vdots\\\left|N-1\right>\end{pmatrix}</script><!-- slide --><p>根据定义</p><script type="math/tex; mode=display">\begin{aligned}\sqrt{N}\left|j\right>&\rightarrow\sum_{k=0}^{N-1}e^{2\pi ijk/N}\left|k\right>\\&=\sum_{k=0}^{N-1}e^{2\pi i k[0.j_1\cdots j_{n}]}\left|k\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}e^{2\pi i [0.j_1\cdots j_{n}]\sum_{l=1}^{n}2^{l-1}k_{n-l}}\left|k_0\cdots k_{n-1}\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}\prod_{l=1}^{n} e^{2\pi i k_{n-l}[j_1\cdots j_{l-1}.j_{l}\cdots j_n]}\left|k_0\cdots k_{n-1}\right>\\&=\sum_{(k_0,\cdots,k_{n-1})\in \{0,1\}^n}\prod_{l=1}^{n} e^{2\pi i k_{n-l}[0.j_{l}\cdots j_n]}\left|k_0\cdots k_{n-1}\right>\\&=(\left|0\right>+e^{2\pi i [0.j_n]}\left|1\right>)\otimes \sum_{(k_1,\cdots,k_{n-1})\in \{0,1\}^{(n-1)}}\prod_{l=1}^{n-1} e^{2\pi i k_{n-l}[0.j_{l}\cdots j_n]}\left|k_1\cdots k_{n-1}\right>\\&=\otimes_{l=1}^{n}\left(\left|0\right>+e^{2\pi i[0.j_l\cdots j_n]}\left|1\right>\right)\end{aligned}</script><!-- slide --><p>第四个等式到第五个等式用到事实</p><script type="math/tex; mode=display">e^{2\pi i k_{n-1}[j_1\cdots j_{l-1}.j_l\cdots j_n]}=e^{2\pi i k_{n-1}[j_1\cdots j_{l-1}]}e^{2\pi i k_{n-1}[0.j_{l}\cdots j_{n}]}=1\cdot e^{2\pi i k_{n-1}[0.j_l\cdots j_n]}</script><!-- slide --><h2 id="门实现"><a href="#门实现" class="headerlink" title="门实现"></a>门实现</h2><p>对于目标态</p><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_n]}\left|1\right>)\\&=H\left|j_n\right>\end{aligned}</script><p>对于目标态</p><script type="math/tex; mode=display">\begin{aligned}&\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_{n-1}j_n]}\left|1\right>)\\&=\frac{1}{\sqrt{2}}(\left|0\right>+e^{2\pi i [0.j_{n-1}]}e^{2\pi i [0.0j_n]}\left|1\right>)\end{aligned}</script><!-- slide --><p>可先对$\left|j_{n-1}\right&gt;$做哈德马德变换，再做用$\left|j_{n}\right&gt;$控制$\left|j_{n-1}\right&gt;$的相位门$R_2$，其中</p><script type="math/tex; mode=display">R_m=\begin{pmatrix}1&0\\0&e^{2\pi i /(2^m)}\end{pmatrix}</script><p>具体实现如下图，最后再做sweep门交换一下态即可。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/61/Q_fourier_nqubits.png/1280px-Q_fourier_nqubits.png?1557480175741" alt="quantum fourier"></p><!-- slide --><p>量子傅里叶算法所需门的复杂度为$\Theta(n^2)$，而最快的经典傅里叶算法时离散傅里叶算法，复杂度为$\Theta(n2^n)$。</p><!-- slide --><blockquote><p>证明量子傅里叶变换是酉变换。</p></blockquote><script type="math/tex; mode=display">\begin{aligned}\text{FT}^\dagger\text{FT}\left|j\right>&=\text{FT}^\dagger \left[\frac{1}{\sqrt{N}}\sum_k e^{2\pi ijk/N} \left|k\right>\right]\\&=\frac{1}{N}\sum_k\sum_m e^{2\pi i(j-m)k/N} \left|m\right>\\&=\frac{1}{N}\sum_m N\delta_{jm} \left|m\right>\\&=\left|j\right>\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 量子傅里叶变换 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 量子并行性</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%B9%B6%E8%A1%8C%E6%80%A7/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E5%B9%B6%E8%A1%8C%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>介绍量子并行性的优越以及相关的重要算法。</p><a id="more"></a><h2 id="量子并行性"><a href="#量子并行性" class="headerlink" title="量子并行性"></a>量子并行性</h2><p>假设有函数$f(x):\{0,1\}^n\rightarrow{0,1}$，可以构造门$U_f$使得</p><script type="math/tex; mode=display">U_f \left|x,y\right>=\left|x,y\oplus f(x)\right></script><ul><li>同时得到$f(x)$的值</li></ul><p>取$\left|x,y\right&gt;=\frac{1}{\sqrt{2^n}}\sum_x \left|x\right&gt;\left|0\right&gt;$，作用$U_f$后，得到</p><script type="math/tex; mode=display">U_f \left|x,y\right>=\frac{1}{\sqrt{2^n}}\sum_x \left|x\right>\left|f(x)\right></script><ul><li>Deutsch算法</li></ul><p>上面得到的态在测量时，只能坍缩到某个特定的$\left|f(x)\right&gt;$，因此并不真正意义上的并行。该算法能得到关于$f(x)$的全局信息。<br><img src="/img/Deutsch.png" alt="Deutsch算法"><br>对于以上线路，经过演算可得到：</p><script type="math/tex; mode=display">\left|\psi_3\right>=\pm \left|f(0)\oplus f(1)\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><p>因此第一个比特是$f(x)$的全局信息$f(0)\oplus f(1)$。计算过程用到一个关键点：</p><script type="math/tex; mode=display">U_f \left|x\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}=(-1)^{f(x)}\left|x\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><ul><li>Deutsch-Jozsa算法</li></ul><p>如果Alice手上的$f(x)$确保是常值函数或者平衡函数，Bob如何快速（尽量少次数地交换信息）判断出是什么函数？<br><img src="/img/Deutsch-Jozsa.png" alt="Deutsch-Jozsa算法"><br>根据演化可得到：</p><script type="math/tex; mode=display">\left|\psi_3\right>=\frac{1}{2^n}\sum_z\sum_x(-1)^{f(x)+x\cdot z}\left|z\right>\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}</script><p>注意到，取$\left|z\right&gt;=\left|0\right&gt;^{\otimes n}$时，$\sum_x(-1)^{f(x)}/2^n$对于$f$为常值函数时已经归一化，$\left|z\right&gt;$取不到其他态，因此前$n$个比特只能全为0；当$f$为平衡函数时，$\left|z\right&gt;$中$\left|0\right&gt;^{\otimes n}$项的振幅为0，因此，前$n$个比特必不能全为0。</p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 量子并行性 </tag>
            
            <tag> Deutsch算法 </tag>
            
            <tag> Deutsch-Jozsa算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 量子隐形传态</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E9%9A%90%E5%BD%A2%E4%BC%A0%E6%80%81/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E9%87%8F%E5%AD%90%E9%9A%90%E5%BD%A2%E4%BC%A0%E6%80%81/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>量子隐形传态过程。<br><a id="more"></a></p><h2 id="量子隐形传态"><a href="#量子隐形传态" class="headerlink" title="量子隐形传态"></a>量子隐形传态</h2><p>Alice和Bob的粒子处于纠缠态$\left|\beta_{00}\right&gt;$，Alice需要将态$\left|\psi\right&gt;$传递给Bob，步骤如下：</p><ol><li>Alice对手中的两个比特做用CNOT门</li><li>Alice对手中的第一个比特作用Hadamard门</li><li>Alice测量出两个比特，并把结果告诉Bob</li><li>Bob根据Alice的测量结果分别作用X门和Z门到自己手中的比特上即可</li></ol><p><img src="/img/telepotation.png" alt="量子隐形传态"></p><p>实际上，可以将测量放在$X,Z$操作之后，其原因是，对前两个比特的测量不影响第三个比特的约化密度矩阵。<br><img src="/img/telepotation2.png" alt="量子隐形传态2"></p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 量子隐形传态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 零碎知识点</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>记录零碎知识点。<br><a id="more"></a></p><h2 id="模二加法"><a href="#模二加法" class="headerlink" title="模二加法"></a>模二加法</h2><p>模二加法$\oplus$是不考虑进位的加法，是加法运算的子集，等同于异或，满足交换律结合律</p><script type="math/tex; mode=display">a\oplus a=0, 0\oplus a=a,1\oplus a=\bar{a}</script><h2 id="单比特任意门分解"><a href="#单比特任意门分解" class="headerlink" title="单比特任意门分解"></a>单比特任意门分解</h2><script type="math/tex; mode=display">\begin{aligned}    U&=e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta)\\    &=e^{i\alpha}AXBXC\\    &=e^{i\alpha}R_{\vec{n}}(\theta)\end{aligned}</script><p>上式中：</p><script type="math/tex; mode=display">\begin{aligned}    A&=R_z(\beta)R_y(\gamma/2)\\    B&=R_y(-\gamma/2)R_z(-(\delta+\beta)/2)\\    C&=R_z((\delta-\beta)/2)\\    I&=ABC\end{aligned}</script><h2 id="贝尔态"><a href="#贝尔态" class="headerlink" title="贝尔态"></a>贝尔态</h2><p>先作用Hadmard门，再作用和CNOT门。</p><script type="math/tex; mode=display">\left|\beta_{xy}\right>=\frac{\left|0,y\right>+(-1)^x \left|1,\bar{y}\right>}{\sqrt{2}}</script><p>产生贝尔态的线路：<br><img src="/img/generate_bell_state.png" alt="generate bell state"></p><p>贝尔基测量：<br><img src="/img/bell_basis_measurement.png" alt="bell_basis_measurement"><br>与产生贝尔基矢的线路互逆，（基矢的变换与系数的变换互逆）。</p><h2 id="不同总类的算符"><a href="#不同总类的算符" class="headerlink" title="不同总类的算符"></a>不同总类的算符</h2><ul><li>Hermitian</li></ul><script type="math/tex; mode=display">A=A^\dagger</script><ul><li>Unitary</li></ul><script type="math/tex; mode=display">UU^\dagger=I</script><ul><li>Normal</li></ul><script type="math/tex; mode=display">AA^\dagger=A^\dagger A</script><ul><li>Positive</li></ul><script type="math/tex; mode=display">\left<v\right|A\left|v\right>\ge 0, \text{for any} \left|v\right></script><ul><li>Positive definite</li></ul><script type="math/tex; mode=display">\left<v\right|A\left|v\right> > 0, \text{for any} \left|v\right></script><ul><li>Projector</li></ul><script type="math/tex; mode=display">P=\sum_{i=1}^k \left|i\right>\left<i\right|</script><h2 id="门转换"><a href="#门转换" class="headerlink" title="门转换"></a>门转换</h2><ul><li>控制Z门</li></ul><script type="math/tex; mode=display">\text{C}Z(0,1)=\text{C}Z(1,0)</script><p><img src="/img/cz.png" alt="CZ"></p><ul><li>Hadmard门和CNOT门</li></ul><script type="math/tex; mode=display">H^{\otimes 2}\text{CNOT}(0,1)H^{\otimes 2}=\text{CNOT}(1,0)</script><p><img src="/img/hcnot.png" alt="Hadmard and CNOT"></p><ul><li>控制U门</li></ul><p><img src="/img/cu.png" alt="CU"></p><ul><li>Trotter定理</li></ul><script type="math/tex; mode=display">\lim_{n\rightarrow\infty}(e^{iAt/n}e^{iBt/n})^n=e^{i(A+B)t}</script><ul><li>等分圆求和</li></ul><script type="math/tex; mode=display">\sum_{j=0}^{N-1} e^{2\pi i s j /N}=N\delta_{s0}, s\in \mathbf{N}.</script><p><strong>解释：</strong><br>在复平面内将圆等分$N$分，每次取$sj$分并进行求和，总能将所有等分点取到，如果$s\neq 0$，则求和后为零。</p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 模二加法 </tag>
            
            <tag> 门分解 </tag>
            
            <tag> 贝尔态 </tag>
            
            <tag> 算符分类 </tag>
            
            <tag> Trotter定理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>量子线路求导</title>
      <link href="/2020/03/16/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC/"/>
      <url>/2020/03/16/%E9%87%8F%E5%AD%90%E7%BA%BF%E8%B7%AF%E6%B1%82%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>推导对含参数的量子线路的求导。<br><a id="more"></a></p><h2 id="单比特"><a href="#单比特" class="headerlink" title="单比特"></a>单比特</h2><ul><li>情形1</li></ul><p>单比特旋转算符$R_m$在态$ \left|\psi\right&gt;$和$ \left|\varphi\right&gt;$上的平均值为：</p><script type="math/tex; mode=display">\begin{aligned}    y(\theta) &= \left<\psi\right|R_m(\theta)\left|\varphi\right>\\    &=\left<\psi\right|(\cos\frac{\theta}{2}I-i\sin\frac{\theta}{2}\sigma_m)\left|\varphi\right>\end{aligned}</script><p>对上式求导可得：</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial y}{\partial \theta}    &=\frac{1}{2}\left<\psi\right|(-\sin\frac{\theta}{2}I-i\cos\frac{\theta}{2}\sigma_m)\left|\varphi\right>\\    &=\frac{1}{2}\left<\psi\right|(\sin\frac{\theta+\pi}{2}I-i\cos\frac{\theta+\pi}{2}\sigma_m)\left|\varphi\right>\\    &=\frac{1}{2}\left<\psi\right|R_m(\theta+\pi)\left|\varphi\right>\\    &=\left<\psi\right|\frac{\partial R_m(\theta)}{\partial\theta}\left|\varphi\right>\end{aligned}</script><p>上式中对矩阵求导为对矩阵每个元素求导。进一步，如果参数含有系数则：</p><script type="math/tex; mode=display">y=\left<\psi\right|R_m(a\theta)\left|\varphi\right></script><p>设$\beta=a\theta$，那么有：</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial y}{\partial \theta}&=\frac{\partial y}{\partial \beta}\frac{\partial \beta}{\partial \theta}\\    &=a\frac{\partial y}{\partial \beta}\\    &=\frac{a}{2}\left<\psi\right|R_m(\beta+\pi)\left|\varphi\right>\\    &=\frac{a}{2}\left<\psi\right|R_m(a\theta+\pi)\left|\varphi\right>\end{aligned}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> projectq</span><br><span class="line"><span class="keyword">from</span> projectq.ops <span class="keyword">import</span> Ry, Rz, Rx, All, Measure</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_wavefunc</span><span class="params">(n_qubits, seed=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        np.random.seed(seed)</span><br><span class="line">    w = np.random.random((<span class="number">1</span> &lt;&lt; n_qubits)) + <span class="number">1j</span> * \</span><br><span class="line">        np.random.random((<span class="number">1</span> &lt;&lt; n_qubits))</span><br><span class="line">    <span class="keyword">return</span> w/np.sqrt(np.vdot(w, w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rx</span><span class="params">(theta)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> np.array([[np.cos(theta / <span class="number">2</span>), <span class="number">-1j</span> * np.sin(theta / <span class="number">2</span>)],</span><br><span class="line">                     [<span class="number">-1j</span> * np.sin(theta / <span class="number">2</span>), np.cos(theta / <span class="number">2</span>)]])</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">evl</span><span class="params">(psi0, ops, n_qubits)</span>:</span></span><br><span class="line">    eng = projectq.MainEngine()</span><br><span class="line">    wavefunction = eng.allocate_qureg(n_qubits)</span><br><span class="line">    eng.flush()</span><br><span class="line"></span><br><span class="line">    eng.backend.set_wavefunction(psi0, wavefunction)</span><br><span class="line">    ops | wavefunction[<span class="number">0</span>]</span><br><span class="line">    eng.flush()</span><br><span class="line"></span><br><span class="line">    psi = eng.backend.cheat()[<span class="number">1</span>]</span><br><span class="line">    All(Measure) | wavefunction</span><br><span class="line">    <span class="keyword">return</span> psi</span><br><span class="line"></span><br><span class="line">n_qubits = <span class="number">1</span></span><br><span class="line">psi1 = random_wavefunc(n_qubits)</span><br><span class="line">psi2 = random_wavefunc(n_qubits)</span><br><span class="line">theta = <span class="number">0.234</span></span><br><span class="line">delta_theta = <span class="number">0.001</span></span><br><span class="line"></span><br><span class="line">y0 = np.vdot(psi2, evl(psi1, Rx(theta), n_qubits))</span><br><span class="line">y1 = np.vdot(psi2, evl(psi1, Rx(theta + delta_theta), n_qubits))</span><br><span class="line"></span><br><span class="line">y2 = np.vdot(psi2, rx(theta).dot(psi1))</span><br><span class="line">y3 = np.vdot(psi2, rx(theta + np.pi).dot(psi1)) / <span class="number">2</span></span><br><span class="line">y4 = np.vdot(psi2, rx(theta + delta_theta).dot(psi1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(<span class="string">"y0 =    &#123;&#125;"</span>.format(y0))</span><br><span class="line">print(<span class="string">'np y0 = &#123;&#125;'</span>.format(y2))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"excepted gradient =    &#123;&#125;"</span>.format(</span><br><span class="line">    <span class="number">0.5</span> * np.vdot(psi2, evl(psi1, Rx(theta+np.pi), n_qubits))))</span><br><span class="line">print(<span class="string">'np excepted gradient = &#123;&#125;'</span>.format(y3))</span><br><span class="line"></span><br><span class="line">print(<span class="string">"difference gradient =    &#123;&#125;"</span>.format((y1 - y0) / delta_theta))</span><br><span class="line">print(<span class="string">'np difference gradient = &#123;&#125;'</span>.format((y4 - y2) / delta_theta))</span><br></pre></td></tr></table></figure><ul><li>情形2</li></ul><p>在求某观察量的平均值时，函数的形式通常为：</p><script type="math/tex; mode=display">\begin{aligned}    y&=\left<\psi\right|R_m^\dagger(\theta)HR_m(\theta)\left|\psi\right>\\     &=\left<\psi\right|(\cos\frac{\theta}{2}I+i\sin\frac{\theta}{2}\sigma_m)H(\cos\frac{\theta}{2}I-i\sin\frac{\theta}{2}\sigma_m)\left|\psi\right>\end{aligned}</script><p>因此有：</p><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial y}{\partial\theta}&=\frac{1}{2}\left<\psi\right|(-\sin\frac{\theta}{2}I+i\cos\frac{\theta}{2}\sigma_m)HR_m(\theta)\left|\psi\right>\\    &+\frac{1}{2}\left<\psi\right|R_m^\dagger(\theta)H(-\sin\frac{\theta}{2}I-i\cos\frac{\theta}{2}\sigma_m)\left|\psi\right>\\    &=\frac{1}{2}\left<\psi\right|(\cos\frac{\theta+\pi}{2}I+i\sin\frac{\theta+\pi}{2}\sigma_m)HR_m(\theta)\left|\psi\right>\\    &+\frac{1}{2}\left<\psi\right|R_m^\dagger(\theta)H(\cos\frac{\theta+\pi}{2}I-i\sin\frac{\theta+\pi}{2}\sigma_m)\left|\psi\right>\\    &=\frac{1}{2}\left<\psi\right|R_m^\dagger(\theta+\pi)HR_m(\theta)\left|\psi\right>+\frac{1}{2}\left<\psi\right|R_m^\dagger(\theta)HR_m(\theta+\pi)\left|\psi\right>\\    &=\Re \left[\left<\psi\right|R_m^\dagger(\theta)HR_m(\theta+\pi)\left|\psi\right>\right]\\    &=2\Re \left[\left<\psi\right|R_m^\dagger(\theta)H\frac{\partial R_m(\theta)}{\partial \theta}\left|\psi\right>\right]\end{aligned}</script><h2 id="多比特"><a href="#多比特" class="headerlink" title="多比特"></a>多比特</h2><p>对含参数的线路进行求导时，实际可以直接对含相应参数的门的矩阵元进行求导，在放入线路中演化。</p><h2 id="中间态缓存与并行对量子线路求导的加速"><a href="#中间态缓存与并行对量子线路求导的加速" class="headerlink" title="中间态缓存与并行对量子线路求导的加速"></a>中间态缓存与并行对量子线路求导的加速</h2><p>假设量子线路$C$包含各种不含参数的门和一些含参数的门，总共的门个数为$ \left|C\right|$，举个例子</p><script type="math/tex; mode=display">C(\theta_1,\theta_2,\theta_3)=XXU_1(\theta_1)U_2(\theta_1,\theta_2)U_3(\theta_2)U_4(\theta_1)XXXU_5(\theta_3)U_6(\theta_3)XU_7(\theta_1)U_8(\theta_1)XX</script><p>此线路的参数集合为$\chi={\theta_1,\theta_2,\theta_3}$，且线路长度为$\left|C\right|=16$，参数个数为$\left|\chi\right|=3$。设某个参数$\theta_i$在线路中的位置点的集合为$P_i$，集合中点按照升序进行排列，则对于上述线路有：</p><script type="math/tex; mode=display">\begin{aligned}P_1&=\{2,3,5,12,13\}\\P_2&=\{3,4\}\\P_3&=\{9,10\}\end{aligned}</script><p>为了利用缓存加速求线路梯度，我们需要在指定步骤缓存下演化出的态，以供后续求梯度使用。例如，对于参数$\theta_1$，我们可以在作用$U_1$之前和作用$U_4$之后、作用$U_7$之前和作用$U_8$之后都将态缓存下来，而这种缓存方案也是对$P_1$的一种分割，如这里是将$P_1$分割为了两个子集：</p><script type="math/tex; mode=display">Q_1=\{\{2,3,5\},\{12,13\}\}</script><h3 id="门操作和缓存数分析"><a href="#门操作和缓存数分析" class="headerlink" title="门操作和缓存数分析"></a>门操作和缓存数分析</h3><p><strong>NCA</strong><br>在进行不做缓存处理的精确求导(NO Cache Accurate, NCA)时，求出线路关于$\theta_1$的导数需要进过$\left|C\right|\cdot\left|P_1\right|$次门操作，求出线路的梯度所需要的门操作总数为$\left|C\right|\cdot\sum_i^{\left|\chi\right|}  \left|P_i\right|$。</p><hr><p><strong>NCD</strong><br>在进行不缓存处理的差分求导(NO Cache Diff, NCD)时，我们将所有的$\theta_i\rightarrow\theta_i+\delta\theta$，此时求出线路关于$\theta_1$的导数需要进过$\left|C\right|$次门操作，求出线路的梯度所需要的门操作总数为$ \left|C\right|\cdot\left|\chi\right|$。</p><hr><p><strong>CA</strong><br>在进行缓存处理的精确求导(Cache Accurate, CA)时，以上面的线路和分割为例，求出线路关于$\theta<em>1$的导数需要缓存下$4=2 \left|Q_1\right|$个中间态，利用分部求导法则，对$Q_1$的第一个子集$Q</em>{1,1}$中的门求出导数需要的门操作数是：</p><script type="math/tex; mode=display">\left|Q_{1,1}\right|\cdot(Q_{1,1}[-1]-Q_{1,1}[0]+1)=12</script><p>而求出$\theta_1$的导数所需的门操作总数为：</p><script type="math/tex; mode=display">\sum_j^{\left|Q_1\right|} \left|Q_{1,j}\right|\cdot(Q_{1,j}[-1]-Q_{1,j}[0]+1)=12+4=16</script><p>因此，求出线路的梯度所需要的门操作总数为：</p><script type="math/tex; mode=display">\sum_i^{\left|\chi\right|}\sum_j^{\left|Q_i\right|} \left|Q_{i,j}\right|\cdot(Q_{i,j}[-1]-Q_{i,j}[0]+1)\ge\sum_i^{\left|\chi\right|}\sum_j^{\left|Q_i\right|} \left|Q_{i,j}\right|=\sum_i^{\left|\chi\right|}\left|P_i\right|</script><p>所需要的缓存总数为：</p><script type="math/tex; mode=display">2\sum_i^{\left|\chi\right|}\left|Q_i\right|</script><hr><p><strong>CD</strong><br>在进行缓存处理的差分求导(Cache Diff, CA)时，以上面的线路和分割为例，求出线路关于$\theta<em>1$的导数需要缓存下$4=2 \left|Q_1\right|$个中间态，利用分部求导法则，对$Q_1$的第一个子集$Q</em>{1,1}$中的门求出导数只需将$\theta<em>1\rightarrow\theta_1+\delta\theta$，因此所需的门操作数为$Q</em>{i,j}[-1]-Q_{i,j}[0]+1$，从而对整个线路求梯度的门操作数为：</p><script type="math/tex; mode=display">\sum_i^{\left|\chi\right|}\sum_j^{\left|Q_i\right|}(Q_{i,j}[-1]-Q_{i,j}[0]+1)\ge\sum_i^{\left|\chi\right|}\left|Q_i\right|</script><p>所需要的缓存总数为：</p><script type="math/tex; mode=display">2\sum_i^{\left|\chi\right|}\left|Q_i\right|</script><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><script type="math/tex; mode=display">\begin{array}{|c|c|c|}\hline方法 & 门操作数 & 态缓存数\\\hline\text{NCA} & \left|C\right|\cdot\sum_i^{\left|\chi\right|}  \left|P_i\right| & 0 \\\hline\text{NCD} & \left|C\right|\cdot\left|\chi\right| & 0 \\\hline\text{CA} & \sum_i^{\left|\chi\right|}\sum_j^{\left|Q_i\right|} \left|Q_{i,j}\right|\cdot(Q_{i,j}[-1]-Q_{i,j}[0]+1) & 2\sum_i^{\left|\chi\right|}\left|Q_i\right| \\\hline\text{CD} & \sum_i^{\left|\chi\right|}\sum_j^{\left|Q_i\right|}(Q_{i,j}[-1]-Q_{i,j}[0]+1) & 2\sum_i^{\left|\chi\right|}\left|Q_i\right|\\\hline\end{array}</script>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 泡利算符 </tag>
            
            <tag> 旋转算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 泡利算符性质</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E6%B3%A1%E5%88%A9%E7%AE%97%E7%AC%A6%E6%80%A7%E8%B4%A8/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E6%B3%A1%E5%88%A9%E7%AE%97%E7%AC%A6%E6%80%A7%E8%B4%A8/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>泡利算符的有用性质。<br><a id="more"></a></p><h2 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h2><p>为了方便，取$\sigma_1=\sigma_x,\sigma_2=\sigma_y, \sigma_3=\sigma_z$。<br>对于任意的三位单位矢量$\vec{v}$，有</p><script type="math/tex; mode=display">(\vec{v}\cdot \vec{\sigma})^2 =I</script><p>由此可证明：</p><script type="math/tex; mode=display">\exp{i\theta \vec{v}\cdot \vec{\sigma}}=\cos(\theta)I+i\sin(\theta)\vec{v}\cdot\vec{\sigma}</script><p>更进一步，对于任意函数$f$，有：</p><script type="math/tex; mode=display">f(\theta \vec{v}\cdot\vec{\sigma})=\frac{f(\theta)+f(-\theta)}{2}I+\frac{f(\theta)-f(-\theta)}{2}\vec{v}\cdot\vec{\sigma}</script><p>假设$\vec{v}\cdot\vec{\sigma}$的本征态为$\left|a\right&gt;,\left|b\right&gt;$，并将$\left|0\right&gt;$和$\left|1\right&gt;$本征态基矢上展开：</p><script type="math/tex; mode=display">\begin{aligned}\left|0\right>&=\alpha \left|a\right>+\beta \left|b\right>\\\left|1\right>&=\gamma \left|a\right>+\delta \left|b\right>\end{aligned}</script><p>这里$\alpha,\beta,\gamma,\delta$是一个酉矩阵的矩阵元，所以$\alpha\delta-\beta\gamma=e^{i\theta}$，是一个相位，因此</p><script type="math/tex; mode=display">\frac{\left|01\right>-\left|10\right>}{\sqrt{2}}=e^{i\theta}\frac{\left|ab\right>-\left|ba\right>}{\sqrt{2}}</script><p>所以，对于自旋单态，对于任意的$\vec{v}$方向测量$\vec{v}\cdot\vec{\sigma}$，如果第一个比特测量得到正方向（$\left|a\right&gt;$）则第二个比特位负方向（$\left|b\right&gt;$），反之亦然。</p><p>对易关系：</p><script type="math/tex; mode=display">\left[\sigma_i,\sigma_j\right]=2i\varepsilon_{ijk}\sigma_k</script><p>反对易关系：</p><script type="math/tex; mode=display">\left\{\sigma_i,\sigma_j\right\}=0</script><p>由反对以关系还可以得到：</p><script type="math/tex; mode=display">\sigma_i\sigma_j\sigma_i=-\sigma_j</script><p>其物理图像为，在布洛赫球中，将$j$轴绕$i$转动$\pi$的坐标变换，此时$j$轴变为$-j$轴。</p><p>与Hadmard门的关系：</p><script type="math/tex; mode=display">HXH=Z; HYH=-Y; HZH = X</script><h2 id="泡利矩阵、旋转算符和旋转哈密顿量之间的关系"><a href="#泡利矩阵、旋转算符和旋转哈密顿量之间的关系" class="headerlink" title="泡利矩阵、旋转算符和旋转哈密顿量之间的关系"></a>泡利矩阵、旋转算符和旋转哈密顿量之间的关系</h2><script type="math/tex; mode=display">U=R_i(\omega t)=e^{-i\omega t \sigma_i/2}=\cos(\omega t/2)I-i\sin(\omega t/2)\sigma_i</script><p>对应的哈密顿量为$H=\hbar \omega \sigma_i/2$</p><h2 id="旋转算符的导数"><a href="#旋转算符的导数" class="headerlink" title="旋转算符的导数"></a>旋转算符的导数</h2><script type="math/tex; mode=display">\begin{aligned}    \frac{\partial R_i(\omega t)}{\partial t}&=-\frac{\omega}{2}\sin\frac{\omega t}{2}I-\frac{\omega}{2}i\cos\frac{\omega t}{2}\sigma_i\\    &=-i\frac{\omega}{2}\sigma_i \left[-i\sin\frac{\omega t}{2}\sigma_i+\cos\frac{\omega t}{2}I\right]\\    &=-\frac{i\omega}{2}\sigma_iR_i(\omega t)\\    &=\frac{\omega}{2}R_i(\omega t+\pi)\end{aligned}</script>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 泡利算符 </tag>
            
            <tag> 旋转算符 </tag>
            
            <tag> Hadmard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Notes on Quantum Information - 常用量子门</title>
      <link href="/2020/03/16/Notes-on-Quantum-Information-%E5%B8%B8%E7%94%A8%E9%87%8F%E5%AD%90%E9%97%A8/"/>
      <url>/2020/03/16/Notes-on-Quantum-Information-%E5%B8%B8%E7%94%A8%E9%87%8F%E5%AD%90%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>常用量子门及其性质<br><a id="more"></a></p><ul><li>$\text{Pauli-X}=\sigma_x=R_x(\pi)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}0&1\\1&0\end{pmatrix}</script><ul><li>$R_x(\theta)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}\cos \left(\frac{\theta}{2}\right)&-i\sin \left(\frac{\theta}{2}\right)\\-i\sin \left(\frac{\theta}{2}\right)&\cos \left(\frac{\theta}{2}\right)\end{pmatrix}</script><ul><li>$\text{Pauli-Y}=\sigma_y=R_y(\pi)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}0&-i\\i&0\end{pmatrix}</script><ul><li>$R_y(\theta)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}\cos \left(\frac{\theta}{2}\right)&-\sin \left(\frac{\theta}{2}\right)\\\sin \left(\frac{\theta}{2}\right)&\cos \left(\frac{\theta}{2}\right)\end{pmatrix}</script><ul><li>$\text{Pauli-Z}=\sigma_z=R_z(\pi)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}1&0\\0&-1\end{pmatrix}</script><ul><li>$R_z(\theta)$:</li></ul><script type="math/tex; mode=display">\begin{pmatrix}e^{-i\theta/2}&0\\0&e^{i\theta/2}\end{pmatrix}</script><ul><li>$R_{\vec{n}}(\theta)$：</li></ul><script type="math/tex; mode=display">R_{\vec{n}}(\theta)=\exp(-i\theta \vec{n}\cdot\vec{\sigma}/2)=\cos\frac{\theta}{2}I-i\sin\frac{\theta}{2}\vec{n}\cdot \vec{\sigma}</script><ul><li>Hadamard门</li></ul><script type="math/tex; mode=display">H=\frac{1}{\sqrt{2}}\begin{pmatrix}1&1\\1&-1\end{pmatrix}=\frac{1}{\sqrt{2}}(X+Z)=R_x(\pi)R_y(\pi/2)=XY^{1/2}</script><p>均匀叠加态：</p><script type="math/tex; mode=display">H^{\otimes n}\left|0\right>^{\otimes n}=\frac{1}{\sqrt{2^n}}\sum_{x\in\{0,1\}^n}\left|x\right></script><p>对于单比特时：</p><script type="math/tex; mode=display">H \left|x\right>=\frac{1}{\sqrt{2}}\sum_{z\in \{0,1\}}(-1)^{xz}\left|z\right>=\frac{1}{\sqrt{2}}\sum_{z\in \{0,1\}}e^{ixz\pi}\left|z\right></script><p>更进一步，当初始态为$n$比特任意态时：</p><script type="math/tex; mode=display">H^{\otimes n}\left|x\right>=\frac{1}{\sqrt{2^n}}\sum_{z}(-1)^{x\cdot z}\left|z\right></script><p>其中$x\cdot z$为$\left|x\right&gt;$和$\left|z\right&gt;$逐比特位相乘再求和。</p><ul><li>CNOT门</li></ul><script type="math/tex; mode=display">\begin{pmatrix}1&0&0&0\\0&1&0&0\\0&0&0&1\\0&0&1&0\end{pmatrix}</script><p>或：</p><script type="math/tex; mode=display">\left|A,B\right>\rightarrow \left|A,A\oplus B\right></script><p>任意位置的CNOT门，以6比特1和3控制5为例：</p><script type="math/tex; mode=display">\begin{aligned}&\left|1\right> \left<1\right|\otimes I\otimes \left|1\right> \left<1\right|\otimes I\otimes X\otimes I+\\&\left|0\right> \left<0\right|\otimes I\otimes \left|1\right> \left<1\right|\otimes I\otimes I\otimes I+\\&\left|1\right> \left<1\right|\otimes I\otimes \left|0\right> \left<0\right|\otimes I\otimes I\otimes I+\\&\left|0\right> \left<0\right|\otimes I\otimes \left|0\right> \left<0\right|\otimes I\otimes I\otimes I\\\end{aligned}</script><p>如果直接对态进行操作，则需要将如下态的系数之间做交换：</p><script type="math/tex; mode=display">\left|A,B,C,D,E,F\right>\rightarrow \left|A,B,C,D,(AC)\oplus E,F\right></script><p>这里$\oplus$是模二加法运算。整个过程用伪代码表示为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> BDF <span class="keyword">in</span> &#123;<span class="number">0</span>,<span class="number">1</span>&#125;^<span class="number">3</span>:</span><br><span class="line">    a=(insert <span class="number">110</span> into BDF <span class="keyword">and</span> get <span class="number">1</span>B1D0F)</span><br><span class="line">    b=(insert <span class="number">111</span> into BDF <span class="keyword">and</span> get <span class="number">1</span>B1D1F)</span><br><span class="line">    swap(wavefunction[a], wavefunction[b])</span><br></pre></td></tr></table></figure><ul><li>SWAP门：</li></ul><p>经典计算里，异或运算可以用来交换两个数而不引入中间变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x,y</span><br><span class="line">x=x^y</span><br><span class="line">y=x^y <span class="comment">#y=x^y^y=x^0=x</span></span><br><span class="line">x=x^y <span class="comment">#y=x^y^x=y^0=y</span></span><br></pre></td></tr></table></figure><p>量子计算里，也可以通过三个CNOT门来实现比特交换：</p><script type="math/tex; mode=display">\begin{aligned}\left|a,b\right>&\rightarrow \left|a,a\oplus b\right>\\&\rightarrow \left|a\oplus a\oplus b,a\oplus b\right>=\left|b,a\oplus b\right>\\&\rightarrow \left|b,a\oplus b \oplus b\right>=\left|b,a\right>\end{aligned}</script><ul><li><p>Toffoli门<br>就是CCNOT门。<br>模拟与非门：$T \left|a,b,1\right&gt;=\left|a,b,1\oplus(ab)\right&gt;=\left|a,b,\bar{ab}\right&gt;$<br>模拟FANOUT扇出：$T \left|1,a,0\right&gt;=\left|1,a,a\right&gt;$<br><strong>注意，上述的模拟不是通用的，只对输入为$\left|0\right&gt;$或者$\left|1\right&gt;$适用。</strong></p></li><li><p>相位门</p></li></ul><script type="math/tex; mode=display">S= \begin{pmatrix}1&0\\0&i\end{pmatrix}</script><ul><li>T门</li></ul><script type="math/tex; mode=display">T=\begin{pmatrix}1&0\\0&\exp(i\pi/4)\end{pmatrix}</script><p>易知$S=T^2$。</p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 泡利算符 </tag>
            
            <tag> 量子门 </tag>
            
            <tag> Hadamard </tag>
            
            <tag> CNOT </tag>
            
            <tag> SWAP </tag>
            
            <tag> Toffoli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Note on Quantum Information - 态的基本表述</title>
      <link href="/2020/03/16/Note-on-Quantum-Information-%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BF%B0/"/>
      <url>/2020/03/16/Note-on-Quantum-Information-%E6%80%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A1%A8%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<p>Notes on <em>Quantum Computation and Quantum Information</em>.<br>单比特和多比特量子态的基本表示方式。<br><a id="more"></a></p><h2 id="单比特"><a href="#单比特" class="headerlink" title="单比特"></a>单比特</h2><p>单比特量子态的一般表达式为：</p><script type="math/tex; mode=display">\begin{aligned}    \left|\psi\right>=e^{i\gamma}\left(\cos\frac{\theta}{2}\left|0\right>+e^{i\varphi}\sin\frac{\theta}{2}\left|1\right>\right)\end{aligned}</script><p>这里$\gamma$为全局相位，$\theta$和$\varphi$为布洛赫球中的坐标，<strong>注意，上式中是$\frac{\theta}{2}$</strong>。<br><img src="/img/bloch_sphere.png" alt="布洛赫球"><br>布洛赫球中不同坐标轴表示的单比特量子态</p><script type="math/tex; mode=display">\begin{array}{|c||c|}\hline轴&\left|\psi\right>\\\hline+Z&\left|0\right>\\\hline-Z&\left|1\right>\\\hline+X&\frac{\left|0\right>+\left|1\right>}{\sqrt{2}}\\\hline-X&\frac{\left|0\right>-\left|1\right>}{\sqrt{2}}\\\hline+Y&\frac{\left|0\right>+i\left|1\right>}{\sqrt{2}}\\\hline-Y&\frac{\left|0\right>-i\left|1\right>}{\sqrt{2}}\\\hline \end{array}</script><p><strong>各轴代表的态是对应Pauli算符的本征值，正轴向的态本征值为1，负轴向的态本征值为-1</strong></p><h2 id="多比特"><a href="#多比特" class="headerlink" title="多比特"></a>多比特</h2><p>两比特量子态可表示为：</p><script type="math/tex; mode=display">\left|\varphi\right>=\alpha_{00}\left|00\right>+\alpha_{01}\left|01\right>+\alpha_{10}\left|10\right>+\alpha_{11}\left|11\right>.</script><p>归一化条件为</p><script type="math/tex; mode=display">\sum_{x\in\{0,1\}^2}\left|\alpha_{x}\right|^2</script><p><strong>其中$\{0,1\}^2$表示由0和1构成的所有长度为2的字符串的集合。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 量子信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 量子信息 </tag>
            
            <tag> 布洛赫球 </tag>
            
            <tag> 泡利算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格林函数</title>
      <link href="/2019/10/22/%E6%A0%BC%E6%9E%97%E5%87%BD%E6%95%B0/"/>
      <url>/2019/10/22/%E6%A0%BC%E6%9E%97%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>以势能的求解为例，我们来了解一下格林函数。<br><a id="more"></a><br>假设空间有电荷量分布为 $\rho(r)$ ,则根据高斯定理，我们有空间电场应该满足条件<script type="math/tex">\nabla\cdot E(r)=\frac{\rho(r)}{\varepsilon_0},</script>再根据$E(r)=-\nabla \phi(r)$，结合起来看，我们可以求得电势和电荷分布之间的关系<script type="math/tex">-\nabla^2\phi(r)=\frac{\rho(r)}{\varepsilon_0},</script>此即为泊松方程，进一步我们有</p><script type="math/tex; mode=display">\begin{aligned}-\nabla^2\phi(r_1)&=\frac{\rho(r_1)}{\varepsilon_0}\\&=\frac{1}{\varepsilon_0}\int\delta(r_1-r_2)\rho(r_2)d^3r_2\\&=\frac{1}{\varepsilon_0}\int[-\nabla^2G(r_1,r_2)]\rho(r_2)d^3r_2\\&=-\nabla^2\left\{\frac{1}{\varepsilon_0}\int G(r_1,r_2)\rho(r_2)d^3r_2\right\}\end{aligned}</script><p>其中$G(r_1,r_2)$即为格林函数。所以我们求解此泊松方程等价于求满足<script type="math/tex">-\nabla^2G(r_1,r_2)]=\delta(r_1-r_2)</script>的格林函数即可，然后在利用<script type="math/tex">\phi(r_1)=\frac{1}{\varepsilon_0}\int G(r_1,r_2)\rho(r_2)d^3r_2</script>可求得空间的电势分布。其实，根据电势叠加定理我们可以直接写出<script type="math/tex">\phi(r_1)=\frac{1}{4\pi\varepsilon_0}\int\frac{\rho(r_2)}{\left|r_1-r_2\right|}d^3r_2</script>由此得到的格林函数<script type="math/tex">G(r_1,r_2)=\frac{1}{4\pi}\frac{1}{\left|r_1-r_2\right|}</script>与前式满足泊松方程所解得的格林函数是一致的。对于这种利用格林函数来求解微分方程的方法，我们可以理解为利用点电荷产生的势的叠加来求得总的势。</p><h3 id="更一般的情况"><a href="#更一般的情况" class="headerlink" title="更一般的情况"></a>更一般的情况</h3><p>设我们有算符$\mathcal{L}$，其作用在势分布函数$y(r)$上得到空间源分布$f(r)$，则我们有</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L}y(r)&=f(r)\\&=\int\delta(r-r')f(r')dr'\\&=\int \mathcal{L}G(r,r')f(r')dr'\\&=\mathcal{L}\int G(r,r')f(r')dr'\\\end{aligned}</script><p>并且</p><script type="math/tex; mode=display">\mathcal{L} G(r,r')=\delta(r-r')</script><script type="math/tex; mode=display">y(r)=\int G(r,r')f(r')dr'</script><h3 id="物理学中的一些格林函数"><a href="#物理学中的一些格林函数" class="headerlink" title="物理学中的一些格林函数"></a>物理学中的一些格林函数</h3><script type="math/tex; mode=display">\begin{array}{c|ccc}dim & \nabla^2 & \nabla^2+k^2 & \nabla^2-k^2\\\hline1 & \frac{1}{2}\left|x_1-x_2\right| & -\frac{i}{2k}\exp(ik\left|x_1-x_2\right|) & -\frac{1}{2k}\exp(-k\left|x_1-x_2\right|)\\2 & \frac{1}{2\pi}\ln\left|\rho_1-\rho_2\right| & -\frac{i}{4}H_0^{(1)}(k\left|\rho_1-\rho_2\right|) & -\frac{1}{2\pi}K_0(k\left|\rho_1-\rho_2\right|)\\3 & -\frac{1}{4\pi}\frac{1}{\left|r_1-r_2\right|} & -\frac{\exp(ik\left|r_1-r_2\right|)}{4\pi\left|r_1-r_2\right|} & -\frac{\exp(-k\left|r_1-r_2\right|)}{4\pi\left|r_1-r_2\right|}\end{array}</script><p>其中$H_0^{(1)}$为Hankel函数，$K_0$是modified Bessel函数。</p><blockquote><p>求得格林函数后，如果积分不容易，我们可以采用技术展开的方法来积分，例如波恩近似便是。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
